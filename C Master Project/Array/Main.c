#define _CRT_SECURE_NO_WARNINGS 

#include <stdio.h>
#include <string.h> // 문자열에 관련된 함수원형을 모아 놓은 헤더파일


#pragma region 배열
// int main(void)
// {
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//  int arr[] = { 1,2,3,4 };
//  int arr2[] = { 1,2,3,4,5,6 };
// 
// printf("array의 11번째 배열 : %d \n", arr[2]);
// 
// return 0;
// }
#pragma endregion

#pragma region 배열 가지고놀기

// int main(void)
// {
// 	int arr[10] = { 2,10,30,21,34,23,53,21,9,1 };
// 	int i;
// 	for (i = 0; i < 10; i++)
// 	{
// 		printf("배열의 %d 번째 원소 : %d \n", i + 1, arr[i]);
// 	}
// 	return 0;
// }

#pragma endregion

#pragma region 배열로 평균구하기(scanf_s로 사용할것.)

// int main()
// {
// 	int arr[5];
// 	int i, ave = 0;
// 
// 	for(i = 0; i < 5; i++)
// 	{
// 		printf("%d 번째 학생의 성적은? ", i + 1);
// 		scanf_s("%d", &arr[i]);
// 	}
// 	for (i = 0;i < 5; i++)
// 	{
// 		ave = ave + arr[i];
// 	}
// 
// 	printf("전체 학생의 평균은 : %d \n", ave / 5);
// 	return 0;
// }

#pragma endregion

#pragma region 배열로 반평균을 구한후 합격자와 불합격자 분리

// int main(void)
// {
// 	int arr[10];
// 	int i, ave = 0;
// 	for (i = 0; i < 10; i++)
// 	{
// 		printf("%d 번째 학생의 성적은? ", i + 1);
// 		scanf_s("%d", &arr[i]);
// 	}
// 	for (i = 0; i < 10; i++)
// 	{
// 		ave = ave + arr[i];
// 	}
// 	ave = ave / 10;
// 	printf("전체 학생의 평균은 : %d \n", ave);
// 	for (i = 0; i < 10; i++)
// 	{
// 		printf("학생 %d : ", i + 1);
// 		if (arr[i] >= ave)
// 			printf("합격 \n");
// 		else
// 			printf("불합격 \n");
// 	}
// 
// 	return 0;
// }


#pragma endregion

#pragma region 소수를 구하는 프로그램만들기

// int main(void)
// {
// 	int guess = 5;
// 
// 	int prime[1000];
// 
// 	int index = 1;
// 
// 	int i;
// 	int ok;
// 
// 	prime[0] = 2;
// 	prime[1] = 3;
// 
// 	for (;;)
// 	{
// 		ok = 0;
// 		for (i = 0; i <= index; i++)
// 		{
// 			if (guess % prime[i] != 0)
// 			{
// 				ok++;
// 			}
// 			else
// 			{
// 				break;
// 			}
// 
// 		}
// 		if (ok == (index + 1))
// 		{
// 			index++;
// 			prime[index] = guess;
// 			printf("소수 : %d \n", prime[index]);
// 			if (index == 999) 
// 				break;
// 		}
// 		guess += 2;
// 	}
// 	return 0;
// }



#pragma endregion

#pragma region  배열의 개념이해 문제(오류가 나는이유)

// 1번째 이유
// 왜냐하면 변수는 무조건 최상단에 선언되야 되기 때문입니다! 위와 같이 배열 arr 과 변수 i, ave 가 변수 선언문이 아닌 
// 다른 문장 다음에 나타났으므로 C 컴파일러는 무조건 오류로 처리하게 됩니다. (물론 C++ 에서는 가능합니다)
//애초에 사람이 입력하는 대로 배열의 크기를 임의로 정할 수 는 없는 것이였군요.
// 그렇다면, 그냥 변수 크기 지정시 특정한 값이 들어있는 변수가 가능한지 살펴 봅시다.
// 
// int main(void)
// {
// 	int total;
// 	printf("전체 학생수 : ");
// 	scanf_s("%d", &total);
// 	int arr[total];
// 	int i, ave = 0;
// 
// 	for (i = 0; i < total; i++)
// 	{
// 		printf("%d 번째 학생의 성적은?", i + 1);
// 		scanf_s("%d",&arr[i]);
// 	}
// 	for (i = 0; i < total; i++)
// 	{
// 		ave = ave + arr[i];
// 	}
// 
// 	ave = ave / total;
// 
// 	printf("전체 학생의 평균은 : %d \n", ave);
// 
// 	for (i = 0; i < total; i++)
// 	{
// 		printf("학생 %d : ", i + 1);
// 		if (arr[i] >= ave)
// 		{
// 			printf("합격 \n");
// 		}
// 		else
// 		{
// 			printf("불합격 \n");
// 		}
// 	}
// 	return 0;
// }

// 2 번째 이유
//C 언어에 처음에 배열의 크기를 변수를 통해 정의할 수 없게 규정하고 있기 때문입니다. 
// (사실, '동적 할당' 이라는 방법으로 억지로 해서 정의할 수 있으나 이 부분에 대한 이야기는 나중에 다루도록 합시다.) 
// 왜냐하면 처음에 컴파일러가 배열을 처리할 대 메모리 상에 공간을 잡아야 하는데 이 때, 잡아야 되는 공간의 크기가 반드시 상수로 주어져야 하기 때문입니다. 
// 지금 수준에서 깊게 설명하는 것은 너무 무리인 것 같으니 그냥 '배열의 크기는 변수로 지정할 수 없다' 정도로 넘어가도록 합시다.

// int main(void)
// {
//    int total = 3;
// 	int arr[total];
// 	int i, ave = 0;
// 
// 	for (i = 0; i < total; i++)
// 	{
// 		printf("%d 번째 학생의 성적은?", i + 1);
// 		scanf_s("%d",&arr[i]);
// 	}
// 	for (i = 0; i < total; i++)
// 	{
// 		ave = ave + arr[i];
// 	}
// 
// 	ave = ave / total;
// 
// 	printf("전체 학생의 평균은 : %d \n", ave);
// 
// 	for (i = 0; i < total; i++)
// 	{
// 		printf("학생 %d : ", i + 1);
// 		if (arr[i] >= ave)
// 		{
// 			printf("합격 \n");
// 		}
// 		else
// 		{
// 			printf("불합격 \n");
// 		}
// 	}
// 	return 0;
// }
#pragma endregion

#pragma region 상수

//int main(void)
//{
//	const int a = 3;
//
//	printf("%d",a);
//	return 0;
//}

// 안되는 예시 1번
// 처음 상수를 정의시 값을 정의해 주지 않는다면
// 컴파일 에러 가 발생합니다.
// int main() 
// {
// 	const int a;
// 
// 	printf("%d", a);
// 	return 0;
// }

// 안되는 예시 2번
// 상수는 또한 그 특성 답게 그 값 자체를 바꿀 수 없습니다.
// 아래와 같이 코드를 작동한다면 1번과 같은 에러가 발생합니다.
// int main() {
// 	const int a = 2;
// 
// 	a = a + 3;
// 	printf("%d", a);
// 	return 0;
// }
#pragma endregion

#pragma region 초기화 되지않는 값

// 이 코드가 작동을 안하는이유
// 운영체제는 초기화 되지 않은 변수에 대한 접근 자체를 불허하고 있습니다.
// 이 때문에 우리는 이 변수에 들어있는 값을영영 보지 못하게 됩니다.
// int main(void)
// {
// 	int arr;
// 
// 	printf("초기화되지않는 값 : %d", arr);
// 
// 	return 0;
// }

// 이코드의 값이 이상한이유
// arr[1]에는 이전에 메모리에서 사용했던 쓰레기값이 
// 들어있기때문에 그대로출력된모습이다.
// int main(void)
// {
// 	int arr[3];
// 	arr[0] = 1;
// 	printf("arr[1] 의 값은? : %d", arr[1]);
// 
// 	return 0;
// }

// 정상적으로 출력되는 코드 의 이유
// 그 이유는
//int arr[3] = { 1 }; 와 같이 정의한다면 컴파일러가 내부적으로 아래와 같이 생각하기 때문입니다.
//int arr[3] = { 1, 0, 0 };
//따라서, 자동적으로 우리가 특별히 초기화 하지 않은 원소들에는 0 이 들어가게 됩니다.
// 
// int main(void)
// {
// 	int arr[3] = { 1 };
// 	printf("arr[1] 의 값 은? : %d",arr[1]);
// 
// 	return 0;
// }

#pragma endregion

#pragma region 생각해볼문제!(배열)

// 문제 (1)
// 위에 입력 받은 학생들의 성적 을 높은 순으로 정렬하는 프로그램을 만들어 보세요.

//문제 (2)
//입력 받은 학생들의 성적을 막대 그래프로 나타내는 프로그램을 만들어 보세요.
#pragma endregion

#pragma region 고차원 배열
// 2차원 배열 예제
// int main(void)
// {
// 	int arr[3][3] = { 1,2,3,4,5,6,7,8,9 };
// 
// 	printf("arr 배열의 2행 3열의 수를 출력 : %d \n", arr[1][2]);
// 	printf("arr 배열의 1행 2열의 수를 출력 : %d \n", arr[0][1]);
// 	return 0;
// }

// 학생 점 수 입력받기 
// int main(void)
// {
// 	int score[3][2];
// 	int i, j;
// 
// 	for (i = 0; i < 3; i++)
// 	{
// 		for (j = 0; j < 2; j++)
// 		{
// 			if (j == 0)
// 			{
// 				printf("%d 번째 학생의 국어 점수 : ", i + 1);
// 				scanf_s("%d", &score[i][j]);
// 			}
// 			else if (j == 1)
// 			{
// 				printf("%d 번째 학생의 수학 점수 : ", i + 1);
// 				scanf_s("%d",&score[i][j]);
// 			}
// 
// 		}
// 	}
// 
// 
// 	for (i = 0; i < 3; i++)
// 	{
// 		printf("%d 번째 학생의 국어 점수 : %d, 수학점수 : %d \n", i + 1, score[i][0], score[i][1]);
// 	}
// 
// 	return 0;
// }

#pragma endregion

#pragma region 배열의 기초 복습 (배열의 선언과 사용)
/*이 파트에서 배워볼 핵심키워드
* 배열 선언, 배열초기화, 배열과 반복문, sizeof연산자
*/

// 5명의 나이를 저장할 배열을 선언하고 사용하는 방법
// int main()
// {
// 	int ary[5];               // int형 요소 5개의 배열 선언
// 	                          // ary는 array의 축약어
// 	ary[0] = 10;              // 첫 번째 배열 요소에 10 대입
// 	ary[1] = 20;              // 두 번째 배열 요소에 20 대입
// 	ary[2] = ary[0] + ary[1]; // 첫 번째와 두 번째 요소를 더해 세 번째 요소에 저장
// 	scanf_s("%d", &ary[3]);   // 키보드로 입력받아 네 번째 요소에 저장
// 
// 	printf("%d\n", ary[2]);   // 세 번째 배열 요소 출력
// 	printf("%d\n", ary[3]);
// 	printf("%d\n", ary[4]);   // 마지막 배열 요소는 쓰레기 값
// 	/* 결과: 50
// 	*        30
// 	*        50
// 	*       -858993460(쓰레기 값)
// 	*/      
// 	
// }

/* 변수5개를 개별로해주는것과 배열의 차이점
* int형 변수5개를 하나씩 선언하는것 과 배열은 전체 저장공간의 크기는 같습니다 
* 그러나 메모리가 할당되는 방식에 차이가있습니다.
* 변수를 선언하면 각 변수는 독립된 저장공간을 가지며 각각의 이름을 사용합니다.
* 예시)
* int a, b, c, d, e; 처럼 개별로 변수를 선언할경우
* int a = 1; <- 4바이트의 저장공간 할당
* int b = 2; <- 4바이트의 저장공간 할당 
* int c = 3; <- 4바이트의 저장공간 할당
* int d = 4; <- 4바이트의 저장공간 할당
* int e = 5; <- 4바이트의 저장공간 할당
*/ 

/* 반면에 배열은 저장공간이 연속으로 할당되며 전체공간의 이름이됩니다.
*  (배열은 메모리에 연속된 공간이 할당되며 하나의 이름을 사용한다.)
* 예시)
* int ary[5]; 처럼 배열로 선언할 경우
* ary[5] <- 20byte의 저장공간 할당
* 
* int형 변수는 크기가 4바이트이므로 5개를 연속으로 할당하면 20byte가 할당됩니다.
* 배열의 나누어진 조각을 배열요소(Element)라고 하는데, 각각의 배열 요소는 int형 변수와 똑같이 사용합니다.
* 배열요소는 첨자(index)를 붙여 표현하며 첨자는 0부터 시작합니다.
* 예를 들어서 세 번째 배열요소는 ary[2]와 같은 형식으로 사용합니다.
* 예시
* int ary[5];
* ary[0],ary[1],ary[2],ary[3],ary[4];
*/

/* 배열의 사용
* 배열을 선언할 때와 배열요소를 사용할때 대괄호([]) 속 숫자의 의미는 다릅니다.
* 선언할때는 배열 요소의 전체갯수를 표시하며 사용할때는 각요소가 배열에서 몇번째에 있는지를 의미합니다.
* 이값이 첨자(배열에서의 위치)이며, 배열의 첨자는 0부터 시작하므로 최대 '배열요소개수 -1'까지만
* 사용합니다. 즉 배열요소의 개수가 5개면 첨자는 0부터 4까지만 사용합니다.
* 배열을 선언할때
* int ary[「5」]
*           ↘ 배열요소의 갯수 : 5개        
* 배열 요소를 사용할때
* ary[「0」] = 10;
*       ↘ 배열에서의 위치(첨자) : 첫 번째 배열 요소 
* 
* 배열을 사용할때 주의사항
* ※배열의 첨자가 사용 범위를 벗어날경우
* 배열 ary의 배열 요소 개수가 5개 일때 ary[5]를 사용하면 이는 첨자 사용 범위를 벗어나므로 그결과를 예측할수 없게됩니다.
* 다음 그림과 같이 배열에 할당된 영역을 벗어난 메모리를 사용하므로 첨범한 영역이 어떤 용도로 사용되느냐에 따라 결과가 달라집니다.
*   ▣      ▣     ▣     ▣     ▣      □    ☜ "배열이 아닌 메모리영역" 
* ary[0] ary[1] ary[2] ary[3] ary[4]  ary[5]
* 
* 이경우 컴파일러가 경고 메세지로 알려주기도 하지만 배열 요소에 포인터 연산을 통해 접근하므로 확실한 에러메세지를 표시하지 않습니다.
* (배열과 포인터의 관계는 10장에서 설명됨) 이렇게 범위를 벗어난 영역에 접근하는 배열코드는 실행 단계에서 문제를 일으킬 때나 발견할 수 있으므로
* 버그를 찾아내기가 쉽지않습니다. 따라서 사용범위를 벗어나지않도록 주의해야합니다.
*/

/* 배열의 초기화 방법
*  배열도 변수와 마찬가지로 최초 할당된 저장 공간에는 쓰레기값이 저장 되어 있습니다.
*  그러므로 배열도 원하는 값을 가지려면 선언과 동시에 초기화를 해줘야합니다. 배열은중괄호({})를묶어서
*  초기화합니다.
* 
* 배열 초기화하는방법 
* 1. {} 아주 기초적인 초기화 방법으로 중괄호를 사용하여 초기화시켜줍니다.
* 예시)
* int ary[5] = {1,2,3,4,5};
* 초기값은 첫번째 요소로부터 차례대로 초기화됩니다.
* 
* 2. 초기값이 배열요소의 개수보다 적은경우
* 예시)
* int ary[5] = {1,2,3};
* 이때는 왼쪽부터 차례로 초기화하고 남은 배열은 모두 0으로 채워집니다.
* 
* 3.자동 초기화 기능을 사용한다.
* 예시)
* int ary[1000] = {};
* 이러면 배열 요소 개수가 아무리 많아도 모든 요소를 쉽게 0으로 초기화 할수있습니다.
* 
* 4.배열 요소 개수를 생략하는형태
* 예시)
* int ary[] = {1,2,3};
* 이경우 컴파일러는 초기값 개수만큼 배열 요소 개수를 정하고 저장공간을 할당합니다. 
* 즉 다음과같이 메모리에 저장공간이 할당되고 초기화됩니다.
* ▣ = 1 ▣ = 2 ▣ = 3
* ary[0] ary[1] ary[2]
* 
* 5.double형 배열과 char형 배열을 선언하고 초기화하는경우
* 예시)
* double ary[5] = {1.0, 2.1, 3.2, 4.3, 5.4};
* char ary[5] = {'a', 'p', 'p' , 'l', 'e'};
* 각각의 자료형에 맞게 double형은 실수값으로 초기화 되고,
* char형 배열은 문자로 초기화 됩니다.
* 
* 배열의 초기화는 선언시 최초 한번만 가능합니다. 그이후에는 배열요소에 일일이 값을 대입해야 하며,
* 초기화 때처럼 중괄호({})를 사용한 대입 연산으로 한 번에 값을 바꾸는 것은 불가능합니다.
* 예시)
* ary[0] = 10;
* ary[1] = 20;
* ary[2] = 30;
* ary[3] = 40;
* ary[4] = 50;
*/
#pragma endregion

#pragma region 배열과 반복문
// 배열없이 변수만을 이용해서 코드를 구성한다면 우리는 일일이 각변수에 값을
// 대입하고 코드를 길게 짤수밖에 없을것입니다 하지만 배열과 반복문을 같이사용한다면
// 좀더 가독성이 좋아지고 유지보수성이 좋은 코드를 짤수가 있습니다. 만약 배열을선언하였으나
// 연속된 배열요소를 변수처럼 하나씩 때어서 사용한다면 이는 배열을 제대로 활용하지 못하고 있는것입니다.
// 
// 배열을 제대로 활용하지못하고있는 예시를 보여드리겠습니다.
// 예시)
// int score[5];
// 
// scanf("%d",&score[0]);
// scanf("%d",&score[1]);
// scanf("%d",&score[2]);
// scanf("%d",&score[3]);
// scanf("%d",&score[4]);
// 배열과 반복문을 활용한 예제를 보여드리겠습니다
 
// 배열과 반복문을 사용한 성적처리프로그램

// int main()
// {
// 	int score[5];          // 다섯 과목의 성적을 입력할 int형 배열 선언
// 	int i;                 // 반복 제어 변수
// 	int total = 0;         // 총점을 누적할 변수
// 	double avg;            // 평균을 저장할 변수
// 
// 	for (i = 0; i < 5; i++)        // i가 0부터 4까지 다섯번 반복
// 	{
// 		scanf_s("%d", &score[i]);  //  각 배열 요소에 성적 입력
// 	}
// 	for (i = 0; i < 5; i++)
// 	{
// 		total += score[i];         // 성적을 누적해 총점 계산
// 	}
// 	avg = total / 5.0;             // 평균 계산
// 
// 	for (i = 0; i < 5; i++)
// 	{
// 		printf("%5d", score[i]);   // 성적출력
// 	}
// 	printf("\n");
// 
// 	printf("평균 : %.1lf\n",avg);  // 평균 출력
// 
// 	return 0;
// 
// 	/* 
// 	*  결과 : 80 95 77 84 100 <-직접입력
// 	*          80 95 77 84 100
// 	*  평균 : 87.2
// 	*/
// }
/*
*  배열과 반복문의 활용 설명
*  1. for문의 제어 변수 i를 배열요소의 첨자로 활용할 수 있습니다
*     for문의 제어변수 i를 배열요소의 첨자로 쓰면 반복과정 에서 모든 배열 요소에 값을 입력할 수 있습니다.
*  2. 배열을이용하여 값을 누적시킬때 더편하게 더하거나 뺄수있습니다.
*  두번째for문 을보면 입력한 배열의 값을 total에 반복 누적해서 총점을 구하고있습니다.
*  만약 변수5개로 선언했었더라면 밑의 예제와 같이 일일이 더해야 했을겁니다.
*  total = score[0] + score[1] +score[2] +score[3] score[4];
* 
*  언뜻보면 배열과 반복문을 사용한것보다 쉬워보일지라도 변수가 100개이상이나 1000개이상이되는순간
*  그값을 하나하나 일일이 더하고 수정하는것은 어려울것입니다.
*  배열과 반복문을 잘 활용하면 데이터양에 따라 유연하고 손쉬운대응이 가능합니다.
*  데이터의 수가 늘어나도 반복횟수만 간단히 수정하면 되기 때문입니다.
*/

// sizeof 연산자를 활용한 배열 처리
/*
* 보통 많은 양의 데이터를 처리하므로 배열을 다룰 때는 반복문 사용이 필수입니다. 따라서 배열 요소의
* 개수가 바뀌면 배열을 처리하는 반복문을 모두 수정해야 하는 부담이 있습니다. 이문제의 해결책으로
* 배열 요소의 개수를 직접 계산해 반복문에 사용하는 방법을 사용할 수 있습니다.
* sizeof 연산자로 배열요소의 개수를 구할려면 다음과 같이합니다.
* 예시)
* sizeof(배열명) / sizeof(배열 요소)
*/
// sizeof 연산자를 사용한 배열
// int main()
// {
// 	int score[5];
// 	int i;
// 	int total = 0;
// 	double avg;
// 	int count;                                // 배열 요소의 개수를 저장할 변수
// 
// 	count = sizeof(score) / sizeof(score[0]); // 배열 요소의 개수 계산
// 
// 	for (i = 0; i < count; i++)               // 11행에서 계산한 count 만큼 반복
// 	{
// 		scanf_s("%d", &score[i]);
// 	}
// 
// 	for (i = 0; i < count; i++)  // 11행에서 계산한 count만큼 반복
// 	{
// 		total += score[i];
// 	}
// 	avg = total / (double)count; // 총합을 count로 나누어 평균 계산
// 	
// 	for (i = 0; i < count; i++)  // 11행에서 계산한 count만큼 반복
// 	{
// 		printf("%5d", score[i]);
// 	}
// 	printf("\n");
// 
// 	printf("평균 : %.1lf\n", avg);
// 	
// 	return 0;
// 
// 	/* 결과 : 80 95 77 84 100 <-입력
// 	*       :  80 95 77 84 100
// 	*       : 평균 : 87.2
// 	*/ 
// 	
// }

// 부가 설명 sizeof 를사용한이유
/* 11행에서 배열요쇼의 개수를 계산합니다. sizeof 연산자를 배열명에 사용하면 배열 전체의 크기를 바이트단위로 계산합니다.
* 이 값을 배열 요소하나의 크기로 나누면 배열 요소의 개수를 구할 수 있습니다.
* 예시)         ↙ 배열 전체 크기(20 바이트)
* count = sizeof(score) / sizeof(score[0]);
*    ↖배열 요소의 개수(5)       ↖ 배열 요소 하나의 크기(4바이트)
* 이렇게 구한 배열 요소의 개수를 각 반복문의 반봇 횟수로 사용하면 나중에 배열 선언문에서 요소의 개수를 바꾸더라도 나머지 코드를
* 수정할 필요가 없습니다. 반복문뿐 아니라 배열 요소의 개수가 필요한 모든곳에 count를 사용합니다.
* 22행에서 배열의 평균을 구할 때도 사용했습니다. 단, 이때total과 count가 모두 int형이므로 결과를 소수점이하까지 구하려면
* 형 변환 연산자로 (double)을 사용해서 실수 연산이 되도록 합니다.
* avg = total / (double)count;
*/   


#pragma endregion

#pragma region (4)가지 키워드로 끝내는 핵심 포인트(배열)
/* 1. 배열을 선언하면 많은 변수를 한번에 선언하는 효과를 볼 수 있습니다.
*  2. 배열을 초기화 할때는 중괄호({}) 를 사용한다.
*  3. 배열은 주로 반복문으로 처리한다.
*  4. 배열 전체의 크기를 구할 때 sizeof 연산자를 사용한다.
*/
/*
* 표로 정리하는 핵심 포인트
* 배열의 선언과 요소의 사용
* |    구분    |       사용 예                 |                 기능                    |
* |  배열 선언 |     int ary[5];               | int형 변수 5개를 한번에 확보한다.         |
* | 요소 사용  | ary[0], ary[1], ary[2]        | 배열 요소를 사용할 때는 첨자를 0부터 시작해| 
* |           |  ary[3], ary[4],              | '요소 개수 -1'까지 사용한다.              |
* |  초기화    | int ary[5] = {1, 2, 3, 4, 5}; | 초기화는 중괄호 안에 값을 나열한다.       | 
*/

#pragma endregion

#pragma region 확인 문제(배열의 기초)
// 1. 다음 설명에 따라 배열을 선언하세요
/*⑴ 정수 5개를 저장할 배열 
* 답 제출 : int ary1[5];
* ⑵ 실수 10개를 저장할 배열
* 답 제출 : double ary2[10];
* ⑶ 배열 요소 개수가 3개인 int형 배열
* 답 제출 : int ary3[3];
* ⑷ 첨자의 최댓값이 4인 char형 배열
* 답 제출 : char ary4[5];
*/

// 2. 다음 그림과 일치 하도록 배열을 선언 하고 초기화 하세요.
/* ▣ = 1 ▣ = 2 ▣ = 3 ▣ = 0 ▣ = 0 ▣ = 0
* int형  int형  int형  int형  int형  int형
* 답 제출 : int ary[6] = {1,2,3};
*/

// 3. 다음과 같이 초기화 된 A배열의 값을 복사해 B배열을 채운 후 출력하는 프로그램을 작성하세요.
//   ▣ ▣ ▣ ▣ ▣ ▣  ▣ ▣ ▣ ▣ <- A배열의 값이 복사된 B배열의 상태 
//   1  2  3  1  2  3  1  2  3  1
//int main()
//{
//	int A[3] = { 1,2,3 };        // 초기화된 A배열 
//	int B[10];                   // 초기화 하지않은 B배열
//	int i;
//
//	for (i = 0; i < 10; i++)  // B 배열을 채우기 위해 B 배열 요소의 개수만큼 반복
//	{
//		B[i] = A[i%3];        // A 배열 첨자가 0 ~ 2를 갖도록 나머지(%) 연산자 사용
//	}
//	for (i = 0; i < 10; i++)
//	{
//		printf("%5d",B[i]);   // B 배열 출력
//	}
// return 0;
//}
// 결과 : 1 2 3 1 2 3 1 2 3 1
#pragma endregion

#pragma region 배열의 기초 (2) 문자를 저장하는배열
 /* 배워볼 핵심키워드 
 * char형 배열선언, strcpy , gets, puts
 * char형 배열은 문자들을 메모리에 연속된 공간에 저장할 수 있으므로 주로 문자열을
 * 저장하는 용도로 쓰입니다. 
 * char형 배열을 문자열로 사용하는이유 *
 우리는 평소에 의미를 전달하기 위해 단어를 사용합니다. 단어는 알파벳의 나열이며, 그순서에 따라 단어의 뜻이 달라집니다.
 이런 단어를 컴퓨터에 데이터로 처리하려면 메모리에 문자를 순서에 맞게 연속으로 저장해야합니다. 모든 알파벳 문자는
 한바이트만으로 충분히 표현할수있기 때문에 char형 배열을 사용하는것이 좋습니다 int형이나 short형으로 배열을만들어서
 문자열을 저장할경우 저장공간이 너무많이 소비되기때문에 좋지 않습니다.
 */

//char 형 배열의 선언과 초기화
/*
* char형 배열을 선언할 때 꼭 기억해야 할점은 저장할 문자열의 길이보다 최소한 하나이상 크게배열을 선언해야 한다는것입니다.
* 예를 들어서 문자열 "apple"을 저장할 배열은 배열 요소 개수가 최소한 6개 이상이어야합니다.
* Ex
* ▣ ▣ ▣ ▣ ▣ ▣<-남는 공간이 하나 이상 있어야합니다.
* a  p  p  l  e 
* 이렇게 여분의 공간이 필요한이유는 널 문자(\0)를 저장하기위해서 입니다. 널문자의 기능은 
* 다음 예제를 통해서 살펴 보겠습니다.
*/

// 문자열을 저장하는 char 형 배열 

// int main(void)
// {
// 	char str[80] = "applejam";          // 문자열 초기화
// 
// 	printf("최초 문자열 : %s\n", str);   // 초기화 문자열 출력
// 	printf("문자열 입력 : ");            
// 	// scanf("%s",str);                 // 새로운 문자열 입력
// 	// 이코드는 #define _CRT_SECURE_NO_WARNINGS 라는 코드를사용하지않으면 경고문이 뜨기때문에 scanf_s를사용하자
// 	scanf_s("%s", str, sizeof(str));
// 	printf("입력 후 문자열 : %s\n", str);// 입력된 문자열 출력
// 
// 	return 0;
// }
// 결과 : 최초문자열 : applejam
//       문자열 입력 : grape <- 입력
//       입력후 문자열 : grape
/*
* 부가설명
* char형 배열은 배열 요소의 형태가 char일뿐 int형 배열이나 double형 배열과 다르지않습니다.
* 따라서 초기화도 중괄호를 사용해 문자를 차례로 나열해도 됩니다. 그러나 다음 예시에서도 볼 수 있듯이
* 문자 상수로 초기화 하는 방법은 쉽지 않으므로 문자열 상수로 초기화 하는방법을 많이사용합니다.
* 예시) 문자상수로 하나씩 초기화
* char str[80] = {'a', 'p', 'p','l', 'e', 'j', 'a', 'm'};
* 
* 문자열 상수로 한번에 초기화
* char str[80] = "applejam"
* 
* 널 문자의 용도
* 초기화 한 문자는 배열의 처음부터 차례로 저장되어 문자열을 만듭니다. 이때 남은 배열 요소에는 자동으로
* 0이 채워집니다. 이렇게 char형 배열에 저장된 0을 특별히 널문자(Null character)라고 부릅니다.
* 모든 문자는 아스키 코드값으로 저장되므로 결국 널 문자는 아스키 코드 값이 0인 문자를 말하며,
* 문자 상수로는 \0으로 표현됩니다.
* 
* 예시)
* str 배열 ▣='a'▣='p' ▣='p' ▣='l' ▣='e' ▣='j' ▣='a' ▣='m' ▣ =\0 ▣ =\0 ▣ =\0  
*                                남는배열 요소는 모두 널문자로 채워짐↗    ↗     ↗
* 아스키 코드 값이 0인 문자를 널만자 라는 이름으로 특별히 대접하는 이유는, 널문자가 문자열의 끝을 표시하는 
* 용도로 쓰이기 때문입니다.
* 
* 위 예제의 7행 printf 함수가 배열의 크기와 관계없이 초기화된 문자열만 정확히 출력하는 것도 널문자가 있기때문입니다.
* printf 함수는 char형 배열에서 널문자가 나올 때까지만 출력하도록 만들어져있습니다. 이런규칙은 문자열을 처리하는 모든함수에 적용됩니다.
* 
* 위 예제 9행 scanf 함수로 문자열을 입력받을때도 어김없이 널문자가 사용됩니다.
* 
* scanf 함수가 배열의 처음부터 grape만 입력했다면, 10행의 입력후 문자열 : 다음출력 결과는
* "grapejam"이어야합니다. 그러나 scanf 함수는 사용자가 입력한 문자열 다음에 자동으로 널문자를 추가해 문자열의 끝을
* 표시합니다. 따라서 10행의 printf 함수는 grape까지만 출력합니다.
* 예시)
*  ▣='a'▣='p' ▣='p' ▣='l' ▣='e' ▣='j' ▣='a' ▣='m' ▣ =\0 ▣ =\0 ▣ =\0 
*      ↑     ↑     ↑      ↑      ↑      ↑   
*      g     r     a      p      e     \0 =scanf함수는 마지막 입력문자뒤에 자동으로 널문자를 저장합니다.
* 
* ※만약 char형 배열 선언시 초기화하지 않은 경우※
* char형 배열 선언시 초기화를 하면 남는배열 요소가 0으로 채워지므로 자동으로 문자열의 끝에 널 문자가 저장되나,
* 초기화를 하지않은 상태에서 배열 요소에 문자를 직접 대입한다면 반드시 마지막 문자 다음에는 널문자를 대입해야합니다.
* 
* char str[80]; -> 배열 선언, 초기화 하지않음
* str[0] = 'a'; -> 배열 요소에 직접 문자 대입
* str[1] = 'p';
* str[2] = 'p';
* str[3] = 'l';
* str[4] = 'e';
* str[5] = '\0'; -> 마지막 문자 다음에 반드시 널문자 대입 
*/

/* char형 배열 선언 시 주의할 점
* 1.배열의 크기는 최대한 넉넉히 선언한다.
* 문자열의 길이가 일정하지 않을 경우 예상 가능한 가장 긴 문자열도 저장할 수 있도록 넉넉히 선언해야 합니다. 
* 2.배열 요소의 개수는 최소한 '문자열 길이 + 1'이어야한다.
* 널 문자로 그끝을 표시하므로 최소한 널문자까지 저장할 수 있도록 배열 요소의 개수를 지정해야 합니다.
*/

#pragma endregion

#pragma region 배열의 기초 (3) 문자열 대입
 /* 문자열 대입하는방법
 * char형 배열이 문자열을 저장하는 변수의 역할을 하므로 초기화 된 이후에도 얼마든지 새로운 문자열
 * 을 저장할 수 있습니다. 단 문자열의 길이가 다를 수 있으므로 일반 변수처럼 대입 연산자를 사용하는 것은
 * 불가능합니다. 이때 strcpy함수를 사용합니다.
 * 
 * strcpy 함수의 사용
 * strcpy 함수는 char형 배열에 새로운 문자열을 저장하는 함수로 저장할 문자열의 길이를 파악해 딱
 * 그 길이만큼만 char형 배열에 문자열을 복사합니다. 물론 문자열 끝에 널문자도 자동으로 붙여줍니다.
 * 
 * ※ strcpy 함수를 사용한 코드가 컴파일 되지 않을 때 ※
 * strcpy 함수를 사용한 코드가 컴파일 되지 않을 때는 소스 코드 첫줄에 #define _CRT_SECURE_NO_WARNINGS 문장을
 * 추가합시다.
 */

// 문자열을 대입하는 strcpy함수
// int main()
// {
// 	char str1[80] = "cat";
// 	char str2[80];
// 
// 	strcpy(str1, "tiger");         // str1 배열에 "tiger" 복사
// 	strcpy(str2, str1);            // str2 배열에 str1 배열의 문자열 복사
// 	printf("%s, %s\n",str1,str2);
//  결과 : tiger, tiger
// 	return 0;
// }

/* 부가 설명
* string.h는 문자열을 다루는 함수들의 원형을 모아놓은 라이브러리입니다.
* strcpy를 사용 할려면 string.h 헤더파일을 꼭 선언 해줘야 합니다.
* strcpy 함수의 기본 사용법은 다음과 같습니다.
* 예시)
* strcpy(저장될 배열명, 저장할 문자열) 
*/

// strcpy 함수로 문자열 상수를 char형 배열에 대입하는법
/*9행의 strcpy 함수는 str1 배열에 문자열 "tiger"를 복사해 저장합니다. 즉 첫번째 인수로는 저장 될곳의
* 배열명을 주고 두 번째 인수는 저장할 문자열을 사용합니다. 오른쪽에 있는 값을 왼쪽 변수에 대입하는
* 연산으로 생각해도 좋습니다.
* 예시) 첫번째 인수  두번째 인수
*         ↓        ↙ 
* strcpy(str1,"tiger")
*           ↖  ↙
*           (대입)
* 
* 첫번째 인수는 문자열을 모두 저장 할 수 있도록 충분히 커야 합니다. 
* 아울러 첫 번째 인수에는 문자열 상수를 사용할 수 없습니다. 상수는 바뀌지 않는 값이므로 
* 대입 연산자의 왼쪽에 올수 없는 것과 같은이유입니다.
* 
* 잘못된 예시)
* strcpy("lion","tiger"); <- 이렇게 사용할 수 없다!
*            ↖  ↙
*            (대입X)
* 상수 문자열을 첫번째 인수로 사용해도 컴파일 단계에서는 에러가 발생하지 않습니다. 그러나,
* 이는 실행할 때 문제가 생기므로 주의 해야합니다. 문자열이 포인터로 구현되기 때문에 생기는 문제인데,
* 문자열 상수와 포인터의 관계를 이해하시면 더욱 도움이됩니다. 혼공C 챕터 12에서 설명이 나와있습니다.
* 
* char형 배열에 저장된 문자열을 다른 char형 배열에 대입하기
* 10행에서처럼 두번째 인수에서는 문자열 상수 뿐이아니라 char형 배열의 배열명도 사용할수있습니다.
* 이때는 배열에 저장된 문자열을 다른 char형 배열에 복사합니다.
* 예시)
* strcpy(저장될_배열명, 저장할_배열명); strcpy(str2, str1); 10행
*/

// 배열에 왜 대입연산자를 사용할 수 없을까?
/*
* C언어를 배우는 과정에서 한번쯤은 다음과 같은 코드를 작성하게됩니다.
* 예시)
* char str[80];  // 배열 선언
* str = "apple"; // 배열에 문자열 대입
* 이 대입 연산식은 당연히 수행될듯 하지만, 컴파일 단계에서 에러가 발생합니다. 대입연산자 왼쪽에 사용한 배열명이
* 컴파일 과정에서 배열이 할당된 메모리의 주소 값으로 바뀌기 때문입니다. 예를 들어 str배열이 메모리 100번지부터 할당
* 되었다면 다음과 같이 대입하는 것과 같습니다.
* 예시)
* 100 = "apple"; // 배열명 str은 100으로 바뀜
*     ↖주의: 실제로 이렇게 대입하지는 않습니다!
* 주소값(100)은 상수로 대입 연산자의 왼쪽에 올수 없으므로 컴파일 과정에서 에러가 발생합니다.다만
* strcpy 함수에서 사용할 수 있는 것은 strcpy 함수가 그 위치로 이동해 메모리의 공간을 사용하도록 구현되어 있기
* 때문입니다. 이문제를 정확하게 이해하기 위해서는 배열과 포인터의 관계를 배워야합니다. 일단 여기서는 대입연산자
* 왼쪽에 배열명이 올 수 없다는 라고 정의해두겠습니다.
*/
#pragma endregion

#pragma region 문자열 전용 입출력 함수 : gets,puts

/* gets,puts 함수를 사용하는 이유
* scanf 함수는 char형 배열에 문자열을 입력할수 있으나 중간에 빈칸이있는경우 빈칸전까지만
* 입력합니다. 그러나 gets함수는 빈칸을 포함해 한줄 전체를 문자열로 입력합니다.
* 또한 이함수와 짝을 이루는 문자열 출력 함수 puts도 같이 활용합니다.
* 밑에 예제를 통해서 gets 함수와 puts 함수의 사용법과 특징을 알아보겠습니다.
*/

// 빈칸을 포함한 문자열 입력
// int main()
// {
// 	char str[80];             // char형 배열 선언
// 	printf("문자열 입력 : ");  // 입력 안내 메세지 출력
// 	gets(str);                // 빈칸을 포함한 문자열 입력
// 	puts("입력된 문자열 : ");  // 문자열 상수 출력
// 	puts(str);                // 배열에 저장된 문자열 출력
// 	return 0;
// }
// 결과 : 문자열 입력 : Love is belief... <- 입력
// 입력된 문자열 : Love is belief...

/* 컴파일 에러가 날시 팁
* 코드가 컴파일 되지 않을 때는 소스 코드 첫줄에 #define _CRT_SECURE_NO_WARNINGS 문장을
* 추가합시다.
*/

// 빈칸을 포함해 문자열을 입력하는 gets 함수
/*
* gets 함수의 사용법은 간단합니다 위 예제 gets(str)와 같이 인수로 char형 배열의 배열명을 줍니다.
* 예시)
* gets(char형 배열명) -> gets(str);
* 
* 부가설명
* gets ㅎ마수는 문자열 입력 중간에 빈칸이나 탭 문자를 사용할 수있으며, enter 를 누르기 전까지
* 전체를 하나의 문자열로 배열에 저장합니다. 물론 마지막에 널문자를 붙여서 문자열의 끝을 표시합니다.
* 
* ※gets 함수 사용시 주의점※
* gets 함수를 사용할때 입력할 배열의 크기를 검사하지 않으므로 배열의 크기 보다 긴 문자열을 입력하면 배열을
* 벗어난 메모리 영역을 침범할 가능성이 있습ㄴ디ㅏ. 따라서 입력할 때는 항상 배열의 크기를 고려해야합니다.
* 이문제는 scanf 함수나 strcpy 함수에도 해당되며 컴파일러에 따라 
* 시스템 안전성 문제 때문에 컴파일을 제한하기도 합니다.
* 
* gets와 짝을 이뤄 문자열을 출력하는 puts 함수
* puts 함수는 문자열 상수나 char형 배열의 배열명을 주면 문자열을 화면에 출력합니다. printf 함수의
* 문자열 출력 기능과 같습니다. 단, 문자열을 출력한후에 자동으로 줄을 바꾸는 차이가 있습니다.
* 이 기능은 경우에 따라 편할 수도 있지만 위 예제 7,8행의 실행결과와 같이 문자열을 출력한후에
* 바로 이어서 입력하는것은 불가능합니다.
* 예시)
* printf("문자열 입력 : "); 7행 입력 안내 메시지를 출력하고 줄이 바뀌지 않음
* gets(str);               8행 7행에서 출력한 문자열 바로 옆에서 입력
*/

#pragma endregion

#pragma region 좀더 알아보기 (문자열의 끝에 널 문자가 없다면?)
/* printf 함수를 비롯한 많은 문자열 처리 함수가 널 문자로 문자열의 끝을 확인합니다.
* 따라서 char 형 배열에 무엇을 저장하든 널 문자가 나올 때까지가 하나의 문자열입니다. 만약 필요한 곳에
* 널문자가 없다면 문자열을 다루는 함수의 결과는 예상할 수 없습니다 아래 예제로 살펴보겠습니다.
*/

// 널 문자가 없는 문자열
// int main()
// {
// 	char str[5];
// 
// 	str[0] = 'O';
// 	str[1] = 'K';
// 	printf("%s\n", str);
// 	
// 	return 0;
// }
// 결과 : OK儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆 ? 宮 ?

/* 이상한문자가 출력되는이유
* 5행에서 배열이 초기화 되지않았으므로 배열에는 쓰레기 값이 남아 있습니다.
* char str[5];
* 
* 여기 7,8행에서 직접 문자를 넣고 printf 함수로 출력(9행)하니 OK가 저장된 다음 요소에 널문자가
* 없어 쓰레기 값을 출력합니다.
* str[0] = '0';
* str[1] = 'K';
* printf("%s\n",str);
* 
* 심지어 할당된 배열에 널문자가 없으면 이어지는 메모리 영역까지 출력합니다. 때로는 메모리 접근에러가
* 발생하니 주의해야합니다.
* 예시) 
* ↓널문자가 나올때까지 출력
* ------------------>
* ▣▣▣▣▣  ? ? ? ? ▣=\0
* O K ? ? ?           ↑ 
* ↑ ↑ ↑ ↑ ↑     메모리 어딘가에 있는 널문자.
* str배열에 할당된 메모리 영역
* 쓰레기 값은 메로리 상태에 따라 다를 수 있으므로 출력 결과는 일치하지 않을수 있습니다. 또한
* 우연히도 OK가 저장된 다음 요소의 값이 널 문자였다면 OK까지만 출력될 가능성도 있습니다.
* 그러나 항상 올바른 결과를 보장할 수 없으므로 char형 배열에 문자를 하나씩 대입해 직접 문자열을 만드는경우
* 에는 문자열의 맨 끝에 널문자를 저장해야한다는 사실을 잊지맙시다.
*/
#pragma endregion

#pragma region (4)가지 키워드로 정리하는 핵심 포인트 (문자를 저장하는 배열)
/*
* 1.char 형 배열은 문자열을 저장하는 변수의 역할을 하는 것으로 문자열을 직접 초기화 할 수 있다.
* 2.char 형 배열에 문자열을 저장할 때는 대입 연산자 대신 strcpy 함수를 사용한다.
* 3.char 형 배열에 문자열을 입출력 할때는 scanf,gets,printf,puts 등의 함수를 사용한다.
*/
#pragma endregion
