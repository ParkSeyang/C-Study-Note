#include <stdio.h>

#pragma region 배열
// int main(void)
// {
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//  int arr[] = { 1,2,3,4 };
//  int arr2[] = { 1,2,3,4,5,6 };
// 
// printf("array의 11번째 배열 : %d \n", arr[2]);
// 
// return 0;
// }
#pragma endregion

#pragma region 배열 가지고놀기

// int main(void)
// {
// 	int arr[10] = { 2,10,30,21,34,23,53,21,9,1 };
// 	int i;
// 	for (i = 0; i < 10; i++)
// 	{
// 		printf("배열의 %d 번째 원소 : %d \n", i + 1, arr[i]);
// 	}
// 	return 0;
// }

#pragma endregion

#pragma region 배열로 평균구하기(scanf_s로 사용할것.)

// int main()
// {
// 	int arr[5];
// 	int i, ave = 0;
// 
// 	for(i = 0; i < 5; i++)
// 	{
// 		printf("%d 번째 학생의 성적은? ", i + 1);
// 		scanf_s("%d", &arr[i]);
// 	}
// 	for (i = 0;i < 5; i++)
// 	{
// 		ave = ave + arr[i];
// 	}
// 
// 	printf("전체 학생의 평균은 : %d \n", ave / 5);
// 	return 0;
// }

#pragma endregion

#pragma region 배열로 반평균을 구한후 합격자와 불합격자 분리

// int main(void)
// {
// 	int arr[10];
// 	int i, ave = 0;
// 	for (i = 0; i < 10; i++)
// 	{
// 		printf("%d 번째 학생의 성적은? ", i + 1);
// 		scanf_s("%d", &arr[i]);
// 	}
// 	for (i = 0; i < 10; i++)
// 	{
// 		ave = ave + arr[i];
// 	}
// 	ave = ave / 10;
// 	printf("전체 학생의 평균은 : %d \n", ave);
// 	for (i = 0; i < 10; i++)
// 	{
// 		printf("학생 %d : ", i + 1);
// 		if (arr[i] >= ave)
// 			printf("합격 \n");
// 		else
// 			printf("불합격 \n");
// 	}
// 
// 	return 0;
// }


#pragma endregion

#pragma region 소수를 구하는 프로그램만들기

// int main(void)
// {
// 	int guess = 5;
// 
// 	int prime[1000];
// 
// 	int index = 1;
// 
// 	int i;
// 	int ok;
// 
// 	prime[0] = 2;
// 	prime[1] = 3;
// 
// 	for (;;)
// 	{
// 		ok = 0;
// 		for (i = 0; i <= index; i++)
// 		{
// 			if (guess % prime[i] != 0)
// 			{
// 				ok++;
// 			}
// 			else
// 			{
// 				break;
// 			}
// 
// 		}
// 		if (ok == (index + 1))
// 		{
// 			index++;
// 			prime[index] = guess;
// 			printf("소수 : %d \n", prime[index]);
// 			if (index == 999) 
// 				break;
// 		}
// 		guess += 2;
// 	}
// 	return 0;
// }



#pragma endregion

#pragma region  배열의 개념이해 문제(오류가 나는이유)

// 1번째 이유
// 왜냐하면 변수는 무조건 최상단에 선언되야 되기 때문입니다! 위와 같이 배열 arr 과 변수 i, ave 가 변수 선언문이 아닌 
// 다른 문장 다음에 나타났으므로 C 컴파일러는 무조건 오류로 처리하게 됩니다. (물론 C++ 에서는 가능합니다)
//애초에 사람이 입력하는 대로 배열의 크기를 임의로 정할 수 는 없는 것이였군요.
// 그렇다면, 그냥 변수 크기 지정시 특정한 값이 들어있는 변수가 가능한지 살펴 봅시다.
// 
// int main(void)
// {
// 	int total;
// 	printf("전체 학생수 : ");
// 	scanf_s("%d", &total);
// 	int arr[total];
// 	int i, ave = 0;
// 
// 	for (i = 0; i < total; i++)
// 	{
// 		printf("%d 번째 학생의 성적은?", i + 1);
// 		scanf_s("%d",&arr[i]);
// 	}
// 	for (i = 0; i < total; i++)
// 	{
// 		ave = ave + arr[i];
// 	}
// 
// 	ave = ave / total;
// 
// 	printf("전체 학생의 평균은 : %d \n", ave);
// 
// 	for (i = 0; i < total; i++)
// 	{
// 		printf("학생 %d : ", i + 1);
// 		if (arr[i] >= ave)
// 		{
// 			printf("합격 \n");
// 		}
// 		else
// 		{
// 			printf("불합격 \n");
// 		}
// 	}
// 	return 0;
// }

// 2 번째 이유
//C 언어에 처음에 배열의 크기를 변수를 통해 정의할 수 없게 규정하고 있기 때문입니다. 
// (사실, '동적 할당' 이라는 방법으로 억지로 해서 정의할 수 있으나 이 부분에 대한 이야기는 나중에 다루도록 합시다.) 
// 왜냐하면 처음에 컴파일러가 배열을 처리할 대 메모리 상에 공간을 잡아야 하는데 이 때, 잡아야 되는 공간의 크기가 반드시 상수로 주어져야 하기 때문입니다. 
// 지금 수준에서 깊게 설명하는 것은 너무 무리인 것 같으니 그냥 '배열의 크기는 변수로 지정할 수 없다' 정도로 넘어가도록 합시다.

// int main(void)
// {
//    int total = 3;
// 	int arr[total];
// 	int i, ave = 0;
// 
// 	for (i = 0; i < total; i++)
// 	{
// 		printf("%d 번째 학생의 성적은?", i + 1);
// 		scanf_s("%d",&arr[i]);
// 	}
// 	for (i = 0; i < total; i++)
// 	{
// 		ave = ave + arr[i];
// 	}
// 
// 	ave = ave / total;
// 
// 	printf("전체 학생의 평균은 : %d \n", ave);
// 
// 	for (i = 0; i < total; i++)
// 	{
// 		printf("학생 %d : ", i + 1);
// 		if (arr[i] >= ave)
// 		{
// 			printf("합격 \n");
// 		}
// 		else
// 		{
// 			printf("불합격 \n");
// 		}
// 	}
// 	return 0;
// }
#pragma endregion

#pragma region 상수

//int main(void)
//{
//	const int a = 3;
//
//	printf("%d",a);
//	return 0;
//}

// 안되는 예시 1번
// 처음 상수를 정의시 값을 정의해 주지 않는다면
// 컴파일 에러 가 발생합니다.
// int main() 
// {
// 	const int a;
// 
// 	printf("%d", a);
// 	return 0;
// }

// 안되는 예시 2번
// 상수는 또한 그 특성 답게 그 값 자체를 바꿀 수 없습니다.
// 아래와 같이 코드를 작동한다면 1번과 같은 에러가 발생합니다.
// int main() {
// 	const int a = 2;
// 
// 	a = a + 3;
// 	printf("%d", a);
// 	return 0;
// }
#pragma endregion

#pragma region 초기화 되지않는 값

// 이 코드가 작동을 안하는이유
// 운영체제는 초기화 되지 않은 변수에 대한 접근 자체를 불허하고 있습니다.
// 이 때문에 우리는 이 변수에 들어있는 값을영영 보지 못하게 됩니다.
// int main(void)
// {
// 	int arr;
// 
// 	printf("초기화되지않는 값 : %d", arr);
// 
// 	return 0;
// }

// 이코드의 값이 이상한이유
// arr[1]에는 이전에 메모리에서 사용했던 쓰레기값이 
// 들어있기때문에 그대로출력된모습이다.
// int main(void)
// {
// 	int arr[3];
// 	arr[0] = 1;
// 	printf("arr[1] 의 값은? : %d", arr[1]);
// 
// 	return 0;
// }

// 정상적으로 출력되는 코드 의 이유
// 그 이유는
//int arr[3] = { 1 }; 와 같이 정의한다면 컴파일러가 내부적으로 아래와 같이 생각하기 때문입니다.
//int arr[3] = { 1, 0, 0 };
//따라서, 자동적으로 우리가 특별히 초기화 하지 않은 원소들에는 0 이 들어가게 됩니다.
// 
// int main(void)
// {
// 	int arr[3] = { 1 };
// 	printf("arr[1] 의 값 은? : %d",arr[1]);
// 
// 	return 0;
// }

#pragma endregion

#pragma region 생각해볼문제!(배열)

// 문제 (1)
// 위에 입력 받은 학생들의 성적 을 높은 순으로 정렬하는 프로그램을 만들어 보세요.

//문제 (2)
//입력 받은 학생들의 성적을 막대 그래프로 나타내는 프로그램을 만들어 보세요.
#pragma endregion

#pragma region 고차원 배열
// 2차원 배열 예제
// int main(void)
// {
// 	int arr[3][3] = { 1,2,3,4,5,6,7,8,9 };
// 
// 	printf("arr 배열의 2행 3열의 수를 출력 : %d \n", arr[1][2]);
// 	printf("arr 배열의 1행 2열의 수를 출력 : %d \n", arr[0][1]);
// 	return 0;
// }

// 학생 점 수 입력받기 
// int main(void)
// {
// 	int score[3][2];
// 	int i, j;
// 
// 	for (i = 0; i < 3; i++)
// 	{
// 		for (j = 0; j < 2; j++)
// 		{
// 			if (j == 0)
// 			{
// 				printf("%d 번째 학생의 국어 점수 : ", i + 1);
// 				scanf_s("%d", &score[i][j]);
// 			}
// 			else if (j == 1)
// 			{
// 				printf("%d 번째 학생의 수학 점수 : ", i + 1);
// 				scanf_s("%d",&score[i][j]);
// 			}
// 
// 		}
// 	}
// 
// 
// 	for (i = 0; i < 3; i++)
// 	{
// 		printf("%d 번째 학생의 국어 점수 : %d, 수학점수 : %d \n", i + 1, score[i][0], score[i][1]);
// 	}
// 
// 	return 0;
// }

#pragma endregion

#pragma region 배열의 기초 복습 (배열의 선언과 사용)
// 5명의 나이를 저장할 배열을 선언하고 사용하는 방법
// int main()
// {
// 	int ary[5];               // int형 요소 5개의 배열 선언
// 	                          // ary는 array의 축약어
// 	ary[0] = 10;              // 첫 번째 배열 요소에 10 대입
// 	ary[1] = 20;              // 두 번째 배열 요소에 20 대입
// 	ary[2] = ary[0] + ary[1]; // 첫 번째와 두 번째 요소를 더해 세 번째 요소에 저장
// 	scanf_s("%d", &ary[3]);   // 키보드로 입력받아 네 번째 요소에 저장
// 
// 	printf("%d\n", ary[2]);   // 세 번째 배열 요소 출력
// 	printf("%d\n", ary[3]);
// 	printf("%d\n", ary[4]);   // 마지막 배열 요소는 쓰레기 값
// 	/* 결과: 50
// 	*        30
// 	*        50
// 	*       -858993460(쓰레기 값)
// 	*/      
// 	
// }

/* 변수5개를 개별로해주는것과 배열의 차이점
* int형 변수5개를 하나씩 선언하는것 과 배열은 전체 저장공간의 크기는 같습니다 
* 그러나 메모리가 할당되는 방식에 차이가있습니다.
* 변수를 선언하면 각 변수는 독립된 저장공간을 가지며 각각의 이름을 사용합니다.
* 예시)
* int a, b, c, d, e; 처럼 개별로 변수를 선언할경우
* int a = 1; <- 4바이트의 저장공간 할당
* int b = 2; <- 4바이트의 저장공간 할당 
* int c = 3; <- 4바이트의 저장공간 할당
* int d = 4; <- 4바이트의 저장공간 할당
* int e = 5; <- 4바이트의 저장공간 할당
*/ 

/* 반면에 배열은 저장공간이 연속으로 할당되며 전체공간의 이름이됩니다.
*  (배열은 메모리에 연속된 공간이 할당되며 하나의 이름을 사용한다.)
* 예시)
* int ary[5]; 처럼 배열로 선언할 경우
* ary[5] <- 20byte의 저장공간 할당
* 
* int형 변수는 크기가 4바이트이므로 5개를 연속으로 할당하면 20byte가 할당됩니다.
* 배열의 나누어진 조각을 배열요소(Element)라고 하는데, 각각의 배열 요소는 int형 변수와 똑같이 사용합니다.
* 배열요소는 첨자(index)를 붙여 표현하며 첨자는 0부터 시작합니다.
* 예를 들어서 세 번째 배열요소는 ary[2]와 같은 형식으로 사용합니다.
* 예시
* int ary[5];
* ary[0],ary[1],ary[2],ary[3],ary[4];
*/

/* 배열의 사용
* 배열을 선언할 때와 배열요소를 사용할때 대괄호([]) 속 숫자의 의미는 다릅니다.
* 선언할때는 배열 요소의 전체갯수를 표시하며 사용할때는 각요소가 배열에서 몇번째에 있는지를 의미합니다.
* 이값이 첨자(배열에서의 위치)이며, 배열의 첨자는 0부터 시작하므로 최대 '배열요소개수 -1'까지만
* 사용합니다. 즉 배열요소의 개수가 5개면 첨자는 0부터 4까지만 사용합니다.
* 배열을 선언할때
* int ary[「5」]
*           ↘ 배열요소의 갯수 : 5개        
* 배열 요소를 사용할때
* ary[「0」] = 10;
*       ↘ 배열에서의 위치(첨자) : 첫 번째 배열 요소 
* 
* 배열을 사용할때 주의사항
* ※배열의 첨자가 사용 범위를 벗어날경우
* 배열 ary의 배열 요소 개수가 5개 일때 ary[5]를 사용하면 이는 첨자 사용 범위를 벗어나므로 그결과를 예측할수 없게됩니다.
* 다음 그림과 같이 배열에 할당된 영역을 벗어난 메모리를 사용하므로 첨범한 영역이 어떤 용도로 사용되느냐에 따라 결과가 달라집니다.
*   ▣      ▣     ▣     ▣     ▣      □    ☜ "배열이 아닌 메모리영역" 
* ary[0] ary[1] ary[2] ary[3] ary[4]  ary[5]
* 
* 이경우 컴파일러가 경고 메세지로 알려주기도 하지만 배열 요소에 포인터 연산을 통해 접근하므로 확실한 에러메세지를 표시하지 않습니다.
* (배열과 포인터의 관계는 10장에서 설명됨) 이렇게 범위를 벗어난 영역에 접근하는 배열코드는 실행 단계에서 문제를 일으킬 때나 발견할 수 있으므로
* 버그를 찾아내기가 쉽지않습니다. 따라서 사용범위를 벗어나지않도록 주의해야합니다.
*/

/* 배열의 초기화 방법
*  배열도 변수와 마찬가지로 최초 할당된 저장 공간에는 쓰레기값이 저장 되어 있습니다.
*  그러므로 배열도 원하는 값을 가지려면 선언과 동시에 초기화를 해줘야합니다. 배열은중괄호({})를묶어서
*  초기화합니다.
* 
* 배열 초기화하는방법 
* 1. {} 아주 기초적인 초기화 방법으로 중괄호를 사용하여 초기화시켜줍니다.
* 예시)
* int ary[5] = {1,2,3,4,5};
* 초기값은 첫번째 요소로부터 차례대로 초기화됩니다.
* 
* 2. 초기값이 배열요소의 개수보다 적은경우
* 예시)
* int ary[5] = {1,2,3};
* 이때는 왼쪽부터 차례로 초기화하고 남은 배열은 모두 0으로 채워집니다.
* 
* 3.자동 초기화 기능을 사용한다.
* 예시)
* int ary[1000] = {};
* 이러면 배열 요소 개수가 아무리 많아도 모든 요소를 쉽게 0으로 초기화 할수있습니다.
* 
* 4.배열 요소 개수를 생략하는형태
* 예시)
* int ary[] = {1,2,3};
* 이경우 컴파일러는 초기값 개수만큼 배열 요소 개수를 정하고 저장공간을 할당합니다. 
* 즉 다음과같이 메모리에 저장공간이 할당되고 초기화됩니다.
* ▣ = 1 ▣ = 2 ▣ = 3
* ary[0] ary[1] ary[2]
* 
* 5.double형 배열과 char형 배열을 선언하고 초기화하는경우
* 예시)
* double ary[5] = {1.0, 2.1, 3.2, 4.3, 5.4};
* char ary[5] = {'a', 'p', 'p' , 'l', 'e'};
* 각각의 자료형에 맞게 double형은 실수값으로 초기화 되고,
* char형 배열은 문자로 초기화 됩니다.
* 
* 배열의 초기화는 선언시 최초 한번만 가능합니다. 그이후에는 배열요소에 일일이 값을 대입해야 하며,
* 초기화 때처럼 중괄호({})를 사용한 대입 연산으로 한 번에 값을 바꾸는 것은 불가능합니다.
* 예시)
* ary[0] = 10;
* ary[1] = 20;
* ary[2] = 30;
* ary[3] = 40;
* ary[4] = 50;
*/
#pragma endregion

#pragma region 배열과 반복문
// 배열없이 변수만을 이용해서 코드를 구성한다면 우리는 일일이 각변수에 값을
// 대입하고 코드를 길게 짤수밖에 없을것입니다 하지만 배열과 반복문을 같이사용한다면
// 좀더 가독성이 좋아지고 유지보수성이 좋은 코드를 짤수가 있습니다. 만약 배열을선언하였으나
// 연속된 배열요소를 변수처럼 하나씩 때어서 사용한다면 이는 배열을 제대로 활용하지 못하고 있는것입니다.
// 
// 배열을 제대로 활용하지못하고있는 예시를 보여드리겠습니다.
// 예시)
// int score[5];
// 
// scanf("%d",&score[0]);
// scanf("%d",&score[1]);
// scanf("%d",&score[2]);
// scanf("%d",&score[3]);
// scanf("%d",&score[4]);
// 배열과 반복문을 활용한 예제를 보여드리겠습니다
 
// 배열과 반복문을 사용한 성적처리프로그램

// int main()
// {
// 	int score[5];          // 다섯 과목의 성적을 입력할 int형 배열 선언
// 	int i;                 // 반복 제어 변수
// 	int total = 0;         // 총점을 누적할 변수
// 	double avg;            // 평균을 저장할 변수
// 
// 	for (i = 0; i < 5; i++)        // i가 0부터 4까지 다섯번 반복
// 	{
// 		scanf_s("%d", &score[i]);  //  각 배열 요소에 성적 입력
// 	}
// 	for (i = 0; i < 5; i++)
// 	{
// 		total += score[i];         // 성적을 누적해 총점 계산
// 	}
// 	avg = total / 5.0;             // 평균 계산
// 
// 	for (i = 0; i < 5; i++)
// 	{
// 		printf("%5d", score[i]);   // 성적출력
// 	}
// 	printf("\n");
// 
// 	printf("평균 : %.1lf\n",avg);  // 평균 출력
// 
// 	return 0;
// 
// 	/* 
// 	*  결과 : 80 95 77 84 100 <-직접입력
// 	*          80 95 77 84 100
// 	*  평균 : 87.2
// 	*/
// }
/*
*  배열과 반복문의 활용 설명
*  1. for문의 제어 변수 i를 배열요소의 첨자로 활용할 수 있습니다
*     for문의 제어변수 i를 배열요소의 첨자로 쓰면 반복과정 에서 모든 배열 요소에 값을 입력할 수 있습니다.
*  2. 배열을이용하여 값을 누적시킬때 더편하게 더하거나 뺄수있습니다.
*  두번째for문 을보면 입력한 배열의 값을 total에 반복 누적해서 총점을 구하고있습니다.
*  만약 변수5개로 선언했었더라면 밑의 예제와 같이 일일이 더해야 했을겁니다.
*  total = score[0] + score[1] +score[2] +score[3] score[4];
* 
*  언뜻보면 배열과 반복문을 사용한것보다 쉬워보일지라도 변수가 100개이상이나 1000개이상이되는순간
*  그값을 하나하나 일일이 더하고 수정하는것은 어려울것입니다.
*  배열과 반복문을 잘 활용하면 데이터양에 따라 유연하고 손쉬운대응이 가능합니다.
*  데이터의 수가 늘어나도 반복횟수만 간단히 수정하면 되기 때문입니다.
*/

// sizeof 연산자를 활용한 배열 처리
/*
* 보통 많은 양의 데이터를 처리하므로 배열을 다룰 때는 반복문 사용이 필수입니다. 따라서 배열 요소의
* 개수가 바뀌면 배열을 처리하는 반복문을 모두 수정해야 하는 부담이 있습니다. 이문제의 해결책으로
* 배열 요소의 개수를 직접 계산해 반복문에 사용하는 방법을 사용할 수 있습니다.
* sizeof 연산자로 배열요소의 개수를 구할려면 다음과 같이합니다.
* 예시)
* sizeof(배열명) / sizeof(배열 요소)
*/
// sizeof 연산자를 사용한 배열
int main()
{

}

#pragma endregion
