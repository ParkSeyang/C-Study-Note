#include <stdio.h>

#pragma region 배열과 포인터의 관계
/* 이 파트에서 배울 핵심키워드
* 배열명, 배열요소의 주소, 배열명과 포인터, 배열명의 정수 덧셈, 포인터의 뺄셈
* 배열의 데이터를 자유롭게 다루기위해서는 배열의 구현원리를 이해할 피룡가 있습니다.
* 이 파트 에서는 배열과 포인터의 관계를 밝히고 포인터로 배열을 사용하는 방법을 살펴보겠습니다.
*/
/* 시작하기 전에 알아보기
* 배열은 자료형이 같은 변수를 메모리에 연속으로 할당합니다. 따라서 각 배열 요소는 일정한 간격으로 주소를
* 갖게 됩니다. 예를 들어 int ary[5]; 의 배열이 메모리 100번지부터 할당되고 int형 변수의 크기가 4byte라면
* 각배열 요소의 주소는 100, 104, 108, 112, 116 번지가 됩니다.
* 예시) int ary[5] 의 그림화
* 배열 요소 의 주소→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→
*              ↓       ↓       ↓        ↓       ↓ 
*              ↓       ↓       ↓        ↓       ↓
              100     104     108      112     116
* 배열명 → ary ▣▣▣▣ ▣▣▣▣ ▣▣▣▣ ▣▣▣▣ ▣▣▣▣
* 배열요소  →   ary[0]  ary[1]  ary[2]   ary[3]  ary[4] 
* 
* 결국 첫 번째 요소의 주소를 알면 나머지 요소의 주소도 쉽게 알수 있고 각 주소에 간접 참조 연산을
* 수행하면 모든 배열 요소를 사용 할 수 있습니다. 따라서 컴파일러는 첫 번째 배열 요소의 주소를 쉽게
* 사용하도록 배열명을 컴파일 과정에서 첫 번째 배열 요소의 주소로 변경합니다.
* 
* 추가 설명
* 1. 배열명은 첫 번째 배열 요소의 주소 값
* 2. 배열명은 첫 번째 배열 요소를 가리킴
* 3. *ary는 첫 번째 배열 요소
*/

// 배열명으로 배열 요소 사용하기
/* 주소는 정수처럼 보이지만 자료형에 관한 정보를 갖고있는 특별한 값입니다.
* 따라서 연산을 자유롭게 할 수 없고 정해진 연산만 가능합니다. 정수 덧셈이 대표적인데, 다음과 같이
* 독특한 방식으로 수행됩니다.
* 예시)
* 주소 + 정수 ----> 주소 + (정수 * 주소를 구한 변수의 크기)
* 
* 예를 들어 크기가 4바이트인 int형 변수 a의 주소 100번지에 1을 더한 결과는 101이 아닌 104가 됩니다.
* 물론 연산 결과 또한 주소가됩니다.
* 예시)  100 101 102 103
* 변수 a  ▣  ▣  ▣  ▣
* &a ● a의 주소 값(100번지)
*    ● a를 가리킨다.
*    ● int형을 가리킨다(a가 int형이므로).
* &a + 1 ---> 100 + (1 * sizeof(int)) ---> "104"
* ● int형을 가리키는 주소 104번지
* ● 104번지 부터 107번지 까지 4바이트 저장 공간의 주소 값
* 
* 이런 연산 규칙은 배열을 사용할 때 유용합니다. 배열명도 주소이므로 정수를 차례로 더하면 연속된
* 배열 요소의 주소를 구할 수 있고 여기에 간접 참조 연산을 수행하면 모든 배열 요소를 사용할 수 있습니다.
* 배열명을 주소로 활용하는 예를 살펴 보겠습니다. ex) 배열명은 첫 번째 배열 요소의 주소 값이다.
*/
// 배열명에 정수 연산을 수행해 배열 요소 사용
// int main()
// {
//     int ary[3];
// 
//     int i;
// 
//     *(ary + 0) = 10;               // ary[0] = 10;
//     *(ary + 1) = *(ary + 0) + 10;  // ary[1] = ary[0] + 10
// 
//     printf("세 번째 배열 요소에 키보드 입력 : ");
//     scanf_s("%d", ary + 2);        // &ary[2] -> ary + 2
// 
//     for (i = 0; i < 3; i++)        //  모든 배열 요소 출력
//     {
//         printf("%5d", *(ary + i));  // ary[i]
//     }
//     return 0;
// }
// 결과 : 30 <- 입력
//        10 20 30
/* 부가 설명 
*  배열명은 첫 번째 배열요소의 주소이므로 값 자체는 100입니다. 그리고 8행 ary에 0을 더한 결과도
* 그대로 100이 되므로 첫 번째 배열 요소가 주소가 됩니다.
*/

// 배열명처럼 사용되는 포인터
// int main()
// {
//     int ary[3];     // 배열 선언
//     int* pa = ary;  // 포인터에 배열명 저장
//     int i;
// 
//     *pa = 10;              // 첫번째 배열요소에 10값 대입
//     *(pa + 1) = 20;        // 두번째 배열요소에 20값 대입
//     pa[2] = pa[0] + pa[1]; // 대괄호를 써서 pa를 배열명 처럼 사용
// 
//     for (i = 0; i < 3; i++)
//     {
//         printf("%5d", pa[i]);    // 포인터로 모든 배열 요소 출력
//     }
// 
//     return 0;
// }

/* 부가 설명
* 
*/

/* 배열명과 포인터의 차이
* 1.sizeof 연산의 결과가 다릅니다.
* 배열명에 사용하면 배열 전체의 크기를 구하고 포인터에 사용하면 포이넡 하나의 크기를 구합니다.
* 따라서 배열명을 포인터에 저장하면 포인터로 배열 전체의 크기를 확인할 수 없게 됩니다.
* 예시)
* int ary[3];
* int *pa = ary;
* sizeof(ary)  <--- 12바이트 배열 전체 크기
* sizeof(pa)   <---  4바이트 포인터 하나의 크기
* 
* 2.변수와 상수의 차이가 있습니다.
* 포인터는 그값을 바꿀 수 있지만, 배열명은 상수이므로 값을 바꿀수 없습니다.
* 즉 포인터 pa에 1을 더해 다시 pa에 저장할 수는 있으나, 배열명 ary에 1을 더하는것은
* 가능하나 그 값을 다시 저장하는 것은 불가능합니다.
* 예시)
* 포인터는 값을 바꿀수있음 O        배열명은 값을 바꿀 수 없음 X
* pa = pa + 1                     ary = ary + 1
* pa++                            ary++
*/

// 포인터를 이용한 배열의 값 출력
// int main()
// {
//     int ary[3] = { 10,20,30 };
//     int* pa = ary;
//     int i;
// 
//     printf("배열의 값 : ");
//     for (i = 0; i < 3; i++)
//     {
//         printf("%d ", *pa);    // pa가 가리키는 배열 요소 출력
//         pa++;                 // 다음 배열 요소를 가리키도록 pa 값 증가;
//     }
// }

#pragma endregion

