#include <stdio.h>

#pragma region 배열과 포인터의 관계
/* 이 파트에서 배울 핵심키워드
* 배열명, 배열요소의 주소, 배열명과 포인터, 배열명의 정수 덧셈, 포인터의 뺄셈
* 배열의 데이터를 자유롭게 다루기위해서는 배열의 구현원리를 이해할 피룡가 있습니다.
* 이 파트 에서는 배열과 포인터의 관계를 밝히고 포인터로 배열을 사용하는 방법을 살펴보겠습니다.
*/
/* 시작하기 전에 알아보기
* 배열은 자료형이 같은 변수를 메모리에 연속으로 할당합니다. 따라서 각 배열 요소는 일정한 간격으로 주소를
* 갖게 됩니다. 예를 들어 int ary[5]; 의 배열이 메모리 100번지부터 할당되고 int형 변수의 크기가 4byte라면
* 각배열 요소의 주소는 100, 104, 108, 112, 116 번지가 됩니다.
* 예시) int ary[5] 의 그림화
* 배열 요소 의 주소→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→
*              ↓       ↓       ↓        ↓       ↓ 
*              ↓       ↓       ↓        ↓       ↓
              100     104     108      112     116
* 배열명 → ary ▣▣▣▣ ▣▣▣▣ ▣▣▣▣ ▣▣▣▣ ▣▣▣▣
* 배열요소  →   ary[0]  ary[1]  ary[2]   ary[3]  ary[4] 
* 
* 결국 첫 번째 요소의 주소를 알면 나머지 요소의 주소도 쉽게 알수 있고 각 주소에 간접 참조 연산을
* 수행하면 모든 배열 요소를 사용 할 수 있습니다. 따라서 컴파일러는 첫 번째 배열 요소의 주소를 쉽게
* 사용하도록 배열명을 컴파일 과정에서 첫 번째 배열 요소의 주소로 변경합니다.
* 
* 추가 설명
* 1. 배열명은 첫 번째 배열 요소의 주소 값
* 2. 배열명은 첫 번째 배열 요소를 가리킴
* 3. *ary는 첫 번째 배열 요소
*/

// 배열명으로 배열 요소 사용하기
/* 주소는 정수처럼 보이지만 자료형에 관한 정보를 갖고있는 특별한 값입니다.
* 따라서 연산을 자유롭게 할 수 없고 정해진 연산만 가능합니다. 정수 덧셈이 대표적인데, 다음과 같이
* 독특한 방식으로 수행됩니다.
* 예시)
* 주소 + 정수 ----> 주소 + (정수 * 주소를 구한 변수의 크기)
* 
* 예를 들어 크기가 4바이트인 int형 변수 a의 주소 100번지에 1을 더한 결과는 101이 아닌 104가 됩니다.
* 물론 연산 결과 또한 주소가됩니다.
* 예시)  100 101 102 103
* 변수 a  ▣  ▣  ▣  ▣
* &a ● a의 주소 값(100번지)
*    ● a를 가리킨다.
*    ● int형을 가리킨다(a가 int형이므로).
* &a + 1 ---> 100 + (1 * sizeof(int)) ---> "104"
* ● int형을 가리키는 주소 104번지
* ● 104번지 부터 107번지 까지 4바이트 저장 공간의 주소 값
* 
* 이런 연산 규칙은 배열을 사용할 때 유용합니다. 배열명도 주소이므로 정수를 차례로 더하면 연속된
* 배열 요소의 주소를 구할 수 있고 여기에 간접 참조 연산을 수행하면 모든 배열 요소를 사용할 수 있습니다.
* 배열명을 주소로 활용하는 예를 살펴 보겠습니다. ex) 배열명은 첫 번째 배열 요소의 주소 값이다.
*/
// 배열명에 정수 연산을 수행해 배열 요소 사용
// int main()
// {
//     int ary[3];
// 
//     int i;
// 
//     *(ary + 0) = 10;               // ary[0] = 10;
//     *(ary + 1) = *(ary + 0) + 10;  // ary[1] = ary[0] + 10
// 
//     printf("세 번째 배열 요소에 키보드 입력 : ");
//     scanf_s("%d", ary + 2);        // &ary[2] -> ary + 2
// 
//     for (i = 0; i < 3; i++)        //  모든 배열 요소 출력
//     {
//         printf("%5d", *(ary + i));  // ary[i]
//     }
//     return 0;
// }
// 결과 : 30 <- 입력
//        10 20 30
/* 부가 설명 
*  배열명은 첫 번째 배열요소의 주소이므로 값 자체는 100입니다. 그리고 8행 ary에 0을 더한 결과도
* 그대로 100이 되므로 첫 번째 배열 요소가 주소가 됩니다.
*/

// 배열명처럼 사용되는 포인터
// int main()
// {
//     int ary[3];     // 배열 선언
//     int* pa = ary;  // 포인터에 배열명 저장
//     int i;
// 
//     *pa = 10;              // 첫번째 배열요소에 10값 대입
//     *(pa + 1) = 20;        // 두번째 배열요소에 20값 대입
//     pa[2] = pa[0] + pa[1]; // 대괄호를 써서 pa를 배열명 처럼 사용
// 
//     for (i = 0; i < 3; i++)
//     {
//         printf("%5d", pa[i]);    // 포인터로 모든 배열 요소 출력
//     }
// 
//     return 0;
// }

/* 부가 설명
* 
*/

/* 배열명과 포인터의 차이
* 1.sizeof 연산의 결과가 다릅니다.
* 배열명에 사용하면 배열 전체의 크기를 구하고 포인터에 사용하면 포이넡 하나의 크기를 구합니다.
* 따라서 배열명을 포인터에 저장하면 포인터로 배열 전체의 크기를 확인할 수 없게 됩니다.
* 예시)
* int ary[3];
* int *pa = ary;
* sizeof(ary)  <--- 12바이트 배열 전체 크기
* sizeof(pa)   <---  4바이트 포인터 하나의 크기
* 
* 2.변수와 상수의 차이가 있습니다.
* 포인터는 그값을 바꿀 수 있지만, 배열명은 상수이므로 값을 바꿀수 없습니다.
* 즉 포인터 pa에 1을 더해 다시 pa에 저장할 수는 있으나, 배열명 ary에 1을 더하는것은
* 가능하나 그 값을 다시 저장하는 것은 불가능합니다.
* 예시)
* 포인터는 값을 바꿀수있음 O        배열명은 값을 바꿀 수 없음 X
* pa = pa + 1                     ary = ary + 1
* pa++                            ary++
*/

// 포인터를 이용한 배열의 값 출력
// int main()
// {
//     int ary[3] = { 10,20,30 };
//     int* pa = ary;
//     int i;
// 
//     printf("배열의 값 : ");
//     for (i = 0; i < 3; i++)
//     {
//         printf("%d ", *pa);    // pa가 가리키는 배열 요소 출력
//         pa++;                 // 다음 배열 요소를 가리키도록 pa 값 증가;
//     }
// }

// 포인터의 뺄셈과 관계 연산

 // int main()
 // {
 //     int ary[5] = { 10,20,30,40,50 };
 //     int* pa = ary;                     // 첫 번째 배열 요소 주소
 //     int* pb = pa + 3;                  // 네 번째 배열 요소 주소
 // 
 //     printf("pa : %u\n", pa);
 //     printf("pb : %u\n", pb);
 // 
 //     pa++;                              // pa를 다음 배열 요소로 이동
 //     printf("pb - pa : %u\n", pb - pa); // 두 포인터의 뺄셈
 // 
 //     printf("앞에 있는 배열 요소의 값 출력 : ");
 //     if (pa < pb)
 //     {
 //         printf("%d\n", *pa);           // pa가 배열의 앞에 있으면 *pa 출력
 //     }
 //     else
 //     {
 //         printf("%d\n", *pb);           // pb가 배열의 앞에 있으면 *pb 출력
 //     }
 // }

#pragma endregion

#pragma region (5)가지 키워드로 끝내는 핵심 포인트
/*
*  1. 배열명은 첫 번째 요소의 주소이다.
*  2. 포인터에 배열명을 저장하면 포인터를 배열명처럼 사용할 수 있다.
*  3. 배열명의 정수 덧셈은 가리키는 자료형의 크기를 곱해서 더한다.
*  4. 포인터의 뺄셈 결과는 배열 요소 간의 간격 차이를 의미한다.
* 
*  5. 표로 정리하는 핵심 포인트
* // 배열과 포인터
*|          구분           |       사용 예         |              기능
*|         배열명          |     int ary[3];       |  배열명은 첫 번째 요소의 주소 이다.
*|                         |   ary == &ary[0];    | 
*|------------------------------------------------------------------------------------
*|      배열명 + 정수       |     int ary[3];      | 가리키는 자료형의 크기를 곱해서 더한다.
*|                         |     ary + 1;         | ary + (1 * sizeof(*ary))
*|---------------------------------------------------------------------------------------
*|                         |     int ary[3];      |  포인터가 배열명을 저장하면 배열명처럼 쓸수있다.
*|  배열명과 포인터는 같다.  |     int *pa = ary;   |  두 번쨰 배열 요소에 10 대입
*|                         |     pa[1] = 10;      |
*|-------------------------------------------------------------------------------------------------
*| 배열명과 포인터는 다르다. |     ary++; ( X )     |  배열명은 상수이므로 그 값을 바꿀 수 없지만,
*|                         |     pa++;  ( O )     |  포인터는 가능하다.
*/
#pragma endregion

#pragma region 확인문제
/*
* 지금 까지 배열명의 의미를 파악하고 포인터로 배열의 데이터를 다루는 방버을 살펴 봤습니다. 포인터에 배열명을 저장하면 포인터 연산을 통해
* 배열명처럼 사용할 수 있습니다. 포인터로 배열의 어딘가를 가리키면 그 위치부터 포인터로 새로운 배열처럼 쓸 수 있습니다. 문제를 통해 포인터로
* 배열을 다루는 다양한 방법을 익혀 보겠습니다.
*/
// int main()
// {
//     /*
//     * 다음과 같이 배열과 포인터가 초기화되고 밑의 예제처럼 메모리에 할당 되었다고 가정합니다.
//     *  100   108   116  124   132
//     *  ▣▣  ▣▣  ▣▣  ▣▣  ▣▣
//     *  1.2   3.5   7.4  0.5  10.0
//     */
//     double ary[5] = { 1.2,3.5,7.4,0.5,10.0};
//     double* pa = ary;
//     double* pb = ary + 2;
// 
//     /* 1. 다음 각 항목의 값을 생각해 적으세요.
//     * ⑴ ary        ->  100(배열의 시작주소값)
//     * 이유 : 배열명은 첫 번째 배열 요소 ary[0]의 주소를 의미합니다.
//     * ⑵ *(ary + 1) ->  3.5
//     * 이유 : 포인터 연산식 *(ary + 1) 은 배열 요소 표현식 ary[1]과 같습니다.
//     * ⑶ pa + 2     ->  116(ary의 3번째 배열 시작 주소값)
//     * 이유 : pa가 100이고 가리키는 자료형이 double 이므로 100 + (2 * sizeof(double))
//     * 간단하게 표현하자면 *(ary + 2)와 같습니다.
//     * ⑷ pa[3]      ->  0.5
//     * 이유 : pa[3] 는 *(pa + 3) 과 같습니다.
//     * ⑸ *pb        ->  7.4
//     * 이유 : pb는 ary + 2로 초기화되었으므로 *pb는 세 번째 배열요소가 됩니다.
//     * ⑹ pb - pa    ->  2 
//     * 이유 : 116 - 100 / sizeof(double) (116 - 100 = 2 - 0 과 같다)
//     */
// 
//     /* 2. 다음 중 사용법이 맞는 것은 O, 잘못된 표현은 X를 표시하세요.
//     * ⑴ ary[5]      ->  X
//     * 이유 : 배열의 요소값이 5이므로 []괄호안에 첨자는 0~4 까지만 사용가능합니다.
//     * ⑵ ary++       ->  X
//     * 이유 :  ary는 배열명으로 주소 상수 100이므로 증가 연산자를 사용할수없습니다.
//     * ⑶ ++(*ary)    ->  O
//     * 이유 : *ary는 첫 번째 배열 요소이므로 ++(*ary)는 그 값을 다 증가시킵니다.
//     * ⑷ pb[-2]      ->  O
//     * 이유 : 포인터 연산식으로 바꾸면 *(pb - 2)가 되고 pb의 주소값 116에서 가리키는 자료형의 크기(8)를곱해서 빼주면 100이므로
//     * 결국 첫 번째 배열요소의 주소가 됩니다. 여기에 간접 참조 연산을 수행하므로 결국 첫번째 배열 요소를 사용합니다.
//     * ⑸ *(pb + 3)   ->  X
//     * 이유 : 초기화된 pb는 세번째 배열을 가라킵니다. pb +3 는 배열의 할당된 영역을 벗어나므로 쓰레기값이 출력됩니다. 
//     * ⑹ *(++pa)     ->  O
//     * 이유 : ++pa는 전위형이므로 먼저 pa가 두 번째 배열 요소를 가리키도록 하고 이어서 간접참조 연산으로 두 번째 배열 요소를 사용합니다.
//     */
//     
//     // 3. 다음은 포인터 pb로 세 번째 배열 요소부터 마지막 배열 요소까지 출력하는 코드입니다.
//     // 코드가 완성 되도록 빈칸을 채우세요.
//    // for (int i = 0; i < 3; i++)
//    // {
//    //     printf("%.1lf \n", *pb);
//    //     // 정답 : pb++;
//    //     이유 : pb가 가리키는 배열요소를 출력 하고 난후 다음 배열 요소로 이동해야 하므로 증감 연산자를 사용해야합니다.
//    // }
//     
// }
#pragma endregion

#pragma region 배열을 처리하는 함수
/* 배열 의 값을 확인하기 위해 수시로 출력해야 한다면 그 기능을 함수로 만들어 호출하면 됩니다.
* 이때 모든 배열 요소를 함수의 인수로 줘야 할까요? 첫 번째 배열 요소의 주소만 알면 나머지 배열 요소는
* 포인터 연산으로 모두 사용할 수 있습니다. 따라서 함수를 호출할 때는 배열명을 주고 함수의 매개변수로 포인터를 선언합니다.
* 그리고 함수 안에 포인터를 배열명 처럼 사용하면 됩니다.
* 배열명 자체가 주소이므로 그 값을 함수의 인수로 주는 것은 얼마든지 가능합니다. 
* 예제를 통해 함수 의 구체적인 사용법을 살펴보겠습니다.
*/

// 배열을 처리하는 함수
// void print_ary(int* pa);          // 함수 선언
// 
// int main()
// {
// 	int ary[5] = { 10,20,30,40,50 };
// 
// 	print_ary(ary);                // 배열명을 주고 함수 호출
// 
// 	return 0;
// 
// 	// 결과 : 10, 20, 30, 40, 50 
// }
// void print_ary(int* pa)         // 매개변수로 포인터 선언
// {
// 
// 	for (int i = 0; i < 5; i++)
// 	{
// 		printf("%d ", pa[i]);      // pa로 배열 요소 표현식 사용
// 	}
// 
// }

/* 부가 설명
* 
* 
*/ 



// 크기가 다른 배열을 출력하는 함수

// void print_ary(int* pa, int size);             // 함수 선언, 매개변수 2개
// 
// int main()
// {
//     int ary1[5] = { 10,20,30,40,50 };         // 배열 요소의 개수가 5개인 배열
//     int ary2[7] = { 10,20,30,40,50,60,70 };   // 배열 요소의 개수가 7개인 배열
// 
//     print_ary(ary1, 5);                       // ary1 배열 출력, 배열 요소의 개수 전달
//     printf("\n");
//     print_ary(ary2, 7);                       // ary2 배열 출력, 배열 요소의 개수 전달
// 
//     return 0;
// }
// 
// void print_ary(int* pa, int size)            // 배열명과 배열 요소의 개수를 받는 매개변수 선언
// {
//     for (int i = 0; i < size; i++)
//     {
//         printf("%d ", pa[i]);                // size의 값에 따라 반복 횟수 결정
//     }
// }

#pragma endregion

#pragma region (3)가지 키워드로 끝내는 핵심 키워드
/*
* 1. 배열을 출력하는 함수에 필요한 것은 배열명이다.
* 2. 배열에 입력하는 함수에 필요한 것도 배열명이다.
* 3. 배열의 크기가 달라도 입출력을 할 수 있게 하려면 배열요소의 개수를 알아야 한다.
* 
* ※ 표로 정리하는 핵심 포인트 ※
*    배열에 입출력하는 함수
* ------------------------------------------------------------------------------------
* --  |         배열을 출력하는 함수               |         배열에 입력하는 함수       |
* 호출| int ary[5] = { 10, 20, 30, 40, 50};      |  int ary[5];                      |
*     | print_ary(ary, 5);                       |  input_ary(ary, 5);               | 
*------------------------------------------------------------------------------------|
*     |  void print_ary(int *pa, int size)       |  void input_ary(int *pa, int size)|
*     | {                                        | {                                 |
*     |    int i;                                |    int i;                         |
* 정의|    for (i = 0; i < size; i++)            |    for (i = 0; i < size; i++)     |
*     |     {                                    |    {                              |
*     |       printf("%d ", pa[i]);              |      scanf("%d ", pa + i);        |
*     |     }                                    |    }                              |
*     | }                                        | }                                 |
* -----------------------------------------------------------------------------------|
*/
#pragma endregion

#pragma region 확인문제(배열과 포인터 심화)
/* 설명
* 지금까지 배열을 처리하는 함수를 살펴봤습니다. 예제에서 사용한 함수나 최댓값을 찾는 함수외에도 초기화, 검색, 수정, 정렬 등 
* 배열의 데이터를 다루는 다양한 함수를 만들 수 있습니다. 어떤 함수라도 만드는 원리는 같습니다. 배열명을 매개변수로 받고 포인터 연산을 통해 
* 모든 배열요소를 사용하는 방식입니다. 배열을 다루는 함수 문제를 풀면서 배운 내용을 확실히 기억하도록 합시다.
*/

/* 1. 다음과 같이 선언된 함수가 있을 때 함수의 호출이 적합하지 않은 것을 고르세요. 정답 : 3번
* Ex) void func(int *p);
* ⑴. int ary[5];   
*     func(ary);
* 맞는 이유 : 함수와 배열의 변수타입이 일치하고 배열명 ary는 주소이므로 호출이 가능합니다.
* 
* ⑵. int ary[] = { 1,2,3 };  
*     func(ary);
* 맞는 이유 : 함수와 배열의 변수타입이 일치하고 배열명 ary는 주소이므로 호출이 가능합니다.
* 
* ⑶. double ary[5];     
*     func(ary);
* 틀린 이유 : 3번의 ary는 double형 배열이므로 (int*)형 포인터에 대입하면 안됩니다.
* 
* ⑷. int ary[5];       
*     func(ary + 2);
* 맞는 이유 : 1,2번과같이 호출이가능하고 ary + 2는 세번째 배열 요소의 주소를 주고 호출합니다.
*/

/* 2. 다음은 각 달의 일수를 저장한 배열입니다. month[0]은 1월이며, 첨자가 순차적으로 증가할때 월도증 함께 증가합니다.
* month 배열의 값을 한 줄에 5개씩 출력하는 함수를 작성하세요.
* 
* int month[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
* 
* void print_month(int *mp)
* {
*   int i;
*   for( i = 0; i < 12; i++ )
*   {
*    printf("5%d", mp[i]);
*    if( i + 1 % 5 == 0)
*      {
*      printf("\n");
*      }
*   }
* }
*/


// 3. 도전 실전 예제
// 도전! 로또 번호 생성 프로그램
// 설명 : 1 ~ 45 중에 6개의 서로 다른 수를 배열에 입력하고 출력합니다. 입력한 수가 이미 저장된 수와 같으면  에러 메시지를 출력하고 다시입력합니다.
// 다음 함수의 선언과 정의를 참고해 빈 부분을 채워 완성합니다.

void input_nums(int* lotto_nums);  // 배열에 로또 번호를 입력하는 함수
void print_nums(int* lotto_nums);  // 배열에 저장된 값을 출력하는 함수

int main()
{
    int lotto_nums[6];  // 로또 번호를 저장할 배열

    input_nums(lotto_nums);
    print_nums(lotto_nums);
    return 0;
}

// void input_nums(int* lotto_nums)
// {
//     int dup;
//     for (int i = 0; i < 6; i++)
//     {
//         printf("로또 번호를 입력해주세요 : \n");
//         scanf_s("%d", &lotto_nums[i]);
// 
//         for (int j = 0; j < i; j++)
//         {
//             if (lotto_nums[j] == lotto_nums[i])
//             {
//                 printf("같은 번호가 있습니다! 다른번호를 입력해주세요 : ");
//                 scanf_s("%d", &lotto_nums[i]);
//             }
// 
//         }
// 
//         if (lotto_nums[i] < 1 || lotto_nums[i] > 45)
//         {
//             printf("1~45사이의 숫자만 가능합니다.\n");
//             i--;
//             continue;
//         }
//     }
//     
// }


// 풀이 예제
// void input_nums(int* lotto_nums)
// {
//     int num, dup;
// 
// 
//     for (int i = 0; i < 6; i++)
//     {
//         printf("번호 입력 : \n");
//         scanf_s("%d", &num);
//         dup = 0;
// 
//         if (num < 1 || num > 45)
//         {
//             printf("1~45사이의 숫자만 가능합니다.\n");
//             i--;
//             continue;
//         }
// 
//         for (int j = 0; j < i; j++)
//         {
//             if (num == lotto_nums[j])
//             {
//                 dup = 1;
//                 break;
//             }
//         }
//         if (!dup)
//         {
//             lotto_nums[i] = num;
//         }
//         else
//         {
//             printf("같은 번호가 있습니다!\n");
//             i--;
//         }
//     }
// 
// }

void print_nums(int* lotto_nums)
{
    printf("로또 번호 : ");
    for (int i = 0; i < 6; i++)
    {
        printf("%d ", lotto_nums[i]);
    }
}

#pragma endregion
