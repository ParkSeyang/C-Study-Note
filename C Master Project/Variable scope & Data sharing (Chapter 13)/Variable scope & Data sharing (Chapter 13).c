#include <stdio.h>

#pragma region 변수 사용 영역 
/* Chapter 13에서 배울것들
* ※ 지역 변수
* ※ 전역 변수
* ※ 정적 지역 변수
* ※ 레지스터 변수
* Chapter 13에서 배울것들 
* 프로그램에서 사용하는 변수는 선언 위치와 방법에 따라 다양한 특징을 가집니다.
* 변수의 특징을 이해하고 필요한 곳에 정확히 사용하면 메모리를 절약하고 신뢰성있는 코드를 만들 수 있습니다.
* 이 절에서는 변수명의 사용 범위와 저장 공간이 할당되는 방식 따라 변수를 나누고 그 특징을 살펴봅니다.
* 
* 이미 Chapter 3에서 변수를 배웠고 지금까지 계속 사용해 왔습니다. 사실 따로 언급하지 않았던 부분이 있는데,
* 지금까지 우리가 사용한 변수는 대부분 지역 변수였습니다. 단순히 "자료형 변수명;" 으로 선언했던것도 사실은
* 지역 변수를 뜻하는 auto라는 예약어가 생략된 문자이었죠. 이밖에도 전역 변수, 레지스터 변수등 변수의 종류는 다양합니다.
* 예시)
* auto 자료형 변수명;
*/
#pragma region 지역 변수란?
/* 지역 변수란?
* 지금까지 사용했던 변수는 지역 변수 (local variable)입니다. 지역 변수는 범위가 함수 내, 즉 일정 지역에서만 사용하는
* 변수입니다. 본래 auto 예약어와 함께 함수 안에 지역 변수를 선언합니다. auto 예약어는 생략할 수 있으며 이 경우 함수 안에
* 선언된 변수는 자동으로 지역 변수가 됩니다.
* Note
* - 지역 변수와 자동 변수(auto variable)는 같은 용어입니다. 지역 변수는 기억 부류 중 하나입니다. 기억 부류(storage class)는
* 변수를 사용 범위와 메모리에서의 존재 기간에 따라 나눈 것입니다. 따라서 지역 변수는 변수의 특성 중 사용 범위를 강조한 것이며
* 자동 변수는 지역 분수가 auto 예약어를 사용하므로 쓰는 용어입니다.
*
* 지역 변수의 특징
* 1.지역 변수는 사용 범위가 블록 내부로 제한되므로 다른 함수에서는 사용할 수 없습니다.
* - 따라서 다른 함수에 같은 이름의 변수를 선언해도 이름이 서로 충돌하지 않습니다.
* 간단한 예제를 통해 확인해보겠습니다.
*/
// 예제 1번) 두 함수에서 같은 이름의 지역 변수를 사용한 경우
// void assign(void);  // 함수 선언
// 
// int main()
// {
// 	auto int a = 0; // 지역 변수 선언과 초기화, auto는 생략 가능
// 
// 	assign();       // 함수 호출;
// 	printf("main 함수 a : %d\n", a);
// 	
// 	return 0;
// }
// 
// void assign(void)
// {
// 	int a;								 // main 함수에 있는 변수와 같은 이름의 지역 변수, auto 생략
// 
// 	a = 10;								 // assign 함수 안에 선언된 a에 대입
// 	printf("assign 함수 a : %d \n", a);  // assign 함수에 선언된 a값 출력
// }
// 결과 : assign 함수 a : 10
//		  main 함수 a : 0

/* 예제1) 의 부가설명
*  이 프로그램에는 7행과 17행에 같은 이름의 변수를 두 번 선언했지만, 함수가 다르므로 문제가 되지 않습니다.
* 7행의 변수 a는 사용 범위가 main 함수의 블록으로 제한되므로 assign 함수에서 사용할수 없고 17행의 assign 함수안의 변수 a도 main함수에서
* 사용할 수 없기 때문입니다. 따라서 19행에서 a에 10을 대입할 때 컴파일러는 고민하지 않고 assign 함수에 선언된 변수 a를 사용합니다.
* 만약 assign 함수에 변수 a의 선언문이 없다면 19행과 20행에서 a의 정체를 알 수 없으므로 컴파일 에러가 발생합니다.
*/

/* 지역 변수의 특징
* 2. 지역 변수는 이름이 같아도 선언된 함수가 다르면 각각 독립된 저장 공간을 갖습니다.
* - 즉 두함수에 선언된 변수a는 이름만 같을 뿐 메모리에 별도의 저장 공간을 갖습니다. 따라서 assign 함수가 호출된
* 이후에도 main 함수에 있는 a의 값은 바뀌지 않습니다.
*
* 지역 변수 사용의 장점
*
* 1. 메모리를 효율적으로 사용합니다.
* - 지역 변수는 함수 안에서만 사용하므로 함수가 반환되면 그 저장 공간을 계속 유지할 필요가 없습니다.
* 따라서 운영체제는 지역 변수가 선언된 함수가 반환되면 할당된 저장 공간을 자동으로 회수해 재활용합니다.
*
* 2. 디버깅에 유리합니다.
* - 지역 변수는 값에 문제가 있을 때 수정하기 쉽습니다. 예를 들어 10행 에서 출력한 a의 값이 예상한 값이 아닌 경우 a가 선언된 main 함수에서만
* 그 원인을 찾으면 됩니다.
* 그런데 지역 변수가 할당된 저장 공간은 자동으로 초기화되지 않으므로 쓰레기 값이 사용되지 않도록 주의 해야합니다.
* 또한 사용 범위가 하나의 함수로 제한되므로 2개 이상의 함수에서 데이터를 공유하기가 쉽지 않습니다. 그러나 이런 불편함보다
* 장점이 더 크므로 다른 종류의 변수보다 지역 변수를 최우선으로 사용해야 합니다.
*
* Tip!)
* 함수의 매개변수는 지역 변수입니다.
* 함수를 만들 때 괄호 안에 선언하는 매개변수는 호출할 대 전달되는 값을 받기 위해 특별한 위치에 선언하는 것일 뿐
* 사용 범위나 메모리에 존재하는 기간 등 변수가 갖는 모든 특징은 지역 변수와 같습니다.
*/

/* 블록 안에서 사용하는 지역 변수
* 지역 변수는 보통 함수 안에서 선언된 후 함수 끝까지 사용되지만, 선언 위치에 따라 사용 범위가 달라질 수 있습니다.
* 지역 변수의 규칙
* 1. 특정 블록 안에 변수를 선언하면 사용 범위가 블록 내부로 제한됩니다.
* - 메모리에 할당된 저장공간도 블록이 끝나면 자동으로 회수되어 더 이상 존재하지 않습니다.
*/
// 지역 변수를 블록 안에 사용하는 예를 살펴 보겠습니다.
// 예제2) 블록 안에 지역 변수를 상요해 두 변수를 교환하는 프로그램
// int main()
// {
// 	int a = 10, b = 20;
// 	printf("교환 전 a와 b의 값 : %d, %d\n", a, b);
// 	{  // 블록 시작
// 		int temp;	// temp 변수 선언
// 
// 		temp = a;
// 		a = b;      //  a와 b는 5행에 선언된 변수
// 		b = temp;
// 
// 	}  // 블록 끝
// 	printf("교환 후 a와 b의 값 : %d, %d\n", a, b);
// 
// 	return 0;
// }
// 결과 : 교환 전 a와 b의 값 : 10, 20
//       교환 후 a와 b의 값 : 20, 10
/* 부가 설명
* 9행에 선언된 변수 temp는 8행과 14행의 블록 안에 선언된 지역 변수 이므로 사용 범위가 그 블록 내부로 제한됩니다.
* 메모리에 할당된 저장 공간도 14행에서 회수되므로 15행 이후에는 temp를 사용할 수 없습니다. 반면, 5행에 선언된 지역 변수 a와 b는
* main 함수 블록 어디서든 사용할 수 있으므로 main 함수에 포함되어 있는 8 ~ 14행 블록 안에서 얼마든지 사용할 수 있습니다.
* 다만 블록이 중첩된 경우 주의할 규칙이 있습니다.
*/

/* 지역 변수의 규칙
* 2. 사용 가능한 변수가 둘 이상이면 가장 가까운 블록에 선언된 변수를 사용합니다.
* - 예를 들어 예제2)의 9행에 새로운 변수 a,b를 선언하면 8~14행 블록 안에서는 5행에 선언된 변수 a와 b대신
* 가까운 블록에 선언된 9행의 변수 a와 b를 사용합니다. 안쪽 블록에서 선언된 변수a와 b는 메모리에 독립된 저장 공간을 가지므로 안쪽 블록에서
* a나 b값을 바꾸어도 5행의 변수 a와 b값에는 변함이 없습니다. 그리고 안쪽 블록에서 선언된 변수는 블록이 끝나면 저장 공간이 회수되어 더 이상
* 사용할 수 없으므로 결국 15행에서 a,b를 출력하면 바뀌지 안흥ㄴ 5행의 변수 a,b의 값이 출력됩니다.
*
* Tip!)
* 특정 블록 안에 변수를 선언하면 필요한 경우 잠깐 사용하고 메모리를 재활용하는 효과를 볼 수 있습니다.
* 즉, 두 변수 a,b의 값을 바꾸는데 사용할 임시 변수는 블록 안에서만 피룡하므로 블록안에 변수를 선언해
* 잠깐 사용하는 것이 메모리 관리에 도움이 될 수 있습니다. 그러나 중첩된 블록에서 같은 이름의 변수를 선언하면
* 예상치 못한 결과를 얻을 수 있으므로 지양해야 합니다.
* - 지역 변수가 사용한 메모리는 블록이 끝나면 동시에 반환된다 -
*/

#pragma endregion



#pragma endregion

#pragma region 전역 변수란?
/* 전역 변수란??
* 함수 밖에 변수를 선언하면 전역 변수가 됩니다. 전역 변수(global variable)는 특정 함수의 블록에 포함되지 않으므로
* 사용 범위가 함수나 블록으로 제한되지 않습니다.
* 전역 변수의 사용 범위는 프로그램 전체이므로 어떤 함수라도 안에서 직접 쓸 수 있습니다.
*/
// 예제를 통해 좀 더 구체적인 특징을 살펴보겠습니다.
// - 전역 변수를 프로그램 어디에서나 사용할 수 있다 -
// 예제3) 전역 번수의 사용 

// void assign10(void);
// void assign20(void);
// 
// int a;    // 전역 변수 선언
// 
// int main(void)
// {
// 	printf("함수 호출 전 a값 : %d\n", a);  // 전역 변수 a 출력
// 	
// 	assign10();
// 	assign20();
// 
// 	printf("함수 호출 후 a값 : %d\n", a);  // 전역 변수 a 출력
// 
// 	return 0;
// }
// void assign10(void)
// {
// 	a = 10;    // 전역 변수 a에 10 대입
// }
// void assign20(void)
// {
// 	int a;   // 전역 변수와 같은 이름의 지역 변수 선언
// 	a = 20;  // 지역 변수 a에 20 대입
// }

// 결과 : 함수 호출 전 a값 : 0
//      : 함수 호출 후 a값 : 10

/* 부가설명 
* 예제3)의 6행이 전역 변수를 선언한 부분입니다. 함수 밖에 변수를 선언하면 전역 변수가 되며 특별한 예약어는
* 사용하지 않습니다. 전역 변수는 특정 함수 안에 있는 것이 아니므로 저장 공간이 
* 메모리에 존재하는 기간이 지역변수 보다 훨씬 깁니다.
* 프로그램이 실행될 때 메모리에 할당되고 프로그램이 끝날 때가지 존재합니다.
* 따라서 전역 변수를 선언한 위치인 6행부터 그아래에 정의된 main, assign10, assign20
* 3개의 함수 안에서 모두 사용할 수 있습니다.
* - 전역 변수는 프로그램 시작과 동시에 할당되어 종료시까지 존재한다 -
*/

#pragma endregion
