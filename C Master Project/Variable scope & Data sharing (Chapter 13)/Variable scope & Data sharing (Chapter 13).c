#include <stdio.h>

#pragma region 변수 사용 영역 
/* Chapter 13에서 배울것들
* ※ 지역 변수
* ※ 전역 변수
* ※ 정적 지역 변수
* ※ 레지스터 변수
* Chapter 13에서 배울것들 
* 프로그램에서 사용하는 변수는 선언 위치와 방법에 따라 다양한 특징을 가집니다.
* 변수의 특징을 이해하고 필요한 곳에 정확히 사용하면 메모리를 절약하고 신뢰성있는 코드를 만들 수 있습니다.
* 이 절에서는 변수명의 사용 범위와 저장 공간이 할당되는 방식 따라 변수를 나누고 그 특징을 살펴봅니다.
* 
* 이미 Chapter 3에서 변수를 배웠고 지금까지 계속 사용해 왔습니다. 사실 따로 언급하지 않았던 부분이 있는데,
* 지금까지 우리가 사용한 변수는 대부분 지역 변수였습니다. 단순히 "자료형 변수명;" 으로 선언했던것도 사실은
* 지역 변수를 뜻하는 auto라는 예약어가 생략된 문자이었죠. 이밖에도 전역 변수, 레지스터 변수등 변수의 종류는 다양합니다.
* 예시)
* auto 자료형 변수명;
*/
#pragma region 지역 변수란?
/* 지역 변수란?
* 지금까지 사용했던 변수는 지역 변수 (local variable)입니다. 지역 변수는 범위가 함수 내, 즉 일정 지역에서만 사용하는
* 변수입니다. 본래 auto 예약어와 함께 함수 안에 지역 변수를 선언합니다. auto 예약어는 생략할 수 있으며 이 경우 함수 안에
* 선언된 변수는 자동으로 지역 변수가 됩니다.
* Note
* - 지역 변수와 자동 변수(auto variable)는 같은 용어입니다. 지역 변수는 기억 부류 중 하나입니다. 기억 부류(storage class)는
* 변수를 사용 범위와 메모리에서의 존재 기간에 따라 나눈 것입니다. 따라서 지역 변수는 변수의 특성 중 사용 범위를 강조한 것이며
* 자동 변수는 지역 분수가 auto 예약어를 사용하므로 쓰는 용어입니다.
*
* 지역 변수의 특징
* 1.지역 변수는 사용 범위가 블록 내부로 제한되므로 다른 함수에서는 사용할 수 없습니다.
* - 따라서 다른 함수에 같은 이름의 변수를 선언해도 이름이 서로 충돌하지 않습니다.
* 간단한 예제를 통해 확인해보겠습니다.
*/
// 예제 1번) 두 함수에서 같은 이름의 지역 변수를 사용한 경우
// void assign(void);  // 함수 선언
// 
// int main()
// {
// 	auto int a = 0; // 지역 변수 선언과 초기화, auto는 생략 가능
// 
// 	assign();       // 함수 호출;
// 	printf("main 함수 a : %d\n", a);
// 	
// 	return 0;
// }
// 
// void assign(void)
// {
// 	int a;								 // main 함수에 있는 변수와 같은 이름의 지역 변수, auto 생략
// 
// 	a = 10;								 // assign 함수 안에 선언된 a에 대입
// 	printf("assign 함수 a : %d \n", a);  // assign 함수에 선언된 a값 출력
// }
// 결과 : assign 함수 a : 10
//		  main 함수 a : 0

/* 예제1) 의 부가설명
*  이 프로그램에는 7행과 17행에 같은 이름의 변수를 두 번 선언했지만, 함수가 다르므로 문제가 되지 않습니다.
* 7행의 변수 a는 사용 범위가 main 함수의 블록으로 제한되므로 assign 함수에서 사용할수 없고 17행의 assign 함수안의 변수 a도 main함수에서
* 사용할 수 없기 때문입니다. 따라서 19행에서 a에 10을 대입할 때 컴파일러는 고민하지 않고 assign 함수에 선언된 변수 a를 사용합니다.
* 만약 assign 함수에 변수 a의 선언문이 없다면 19행과 20행에서 a의 정체를 알 수 없으므로 컴파일 에러가 발생합니다.
*/

/* 지역 변수의 특징
* 2. 지역 변수는 이름이 같아도 선언된 함수가 다르면 각각 독립된 저장 공간을 갖습니다.
* - 즉 두함수에 선언된 변수a는 이름만 같을 뿐 메모리에 별도의 저장 공간을 갖습니다. 따라서 assign 함수가 호출된
* 이후에도 main 함수에 있는 a의 값은 바뀌지 않습니다.
*
* 지역 변수 사용의 장점
*
* 1. 메모리를 효율적으로 사용합니다.
* - 지역 변수는 함수 안에서만 사용하므로 함수가 반환되면 그 저장 공간을 계속 유지할 필요가 없습니다.
* 따라서 운영체제는 지역 변수가 선언된 함수가 반환되면 할당된 저장 공간을 자동으로 회수해 재활용합니다.
*
* 2. 디버깅에 유리합니다.
* - 지역 변수는 값에 문제가 있을 때 수정하기 쉽습니다. 예를 들어 10행 에서 출력한 a의 값이 예상한 값이 아닌 경우 a가 선언된 main 함수에서만
* 그 원인을 찾으면 됩니다.
* 그런데 지역 변수가 할당된 저장 공간은 자동으로 초기화되지 않으므로 쓰레기 값이 사용되지 않도록 주의 해야합니다.
* 또한 사용 범위가 하나의 함수로 제한되므로 2개 이상의 함수에서 데이터를 공유하기가 쉽지 않습니다. 그러나 이런 불편함보다
* 장점이 더 크므로 다른 종류의 변수보다 지역 변수를 최우선으로 사용해야 합니다.
*
* Tip!)
* 함수의 매개변수는 지역 변수입니다.
* 함수를 만들 때 괄호 안에 선언하는 매개변수는 호출할 대 전달되는 값을 받기 위해 특별한 위치에 선언하는 것일 뿐
* 사용 범위나 메모리에 존재하는 기간 등 변수가 갖는 모든 특징은 지역 변수와 같습니다.
*/

/* 블록 안에서 사용하는 지역 변수
* 지역 변수는 보통 함수 안에서 선언된 후 함수 끝까지 사용되지만, 선언 위치에 따라 사용 범위가 달라질 수 있습니다.
* 지역 변수의 규칙
* 1. 특정 블록 안에 변수를 선언하면 사용 범위가 블록 내부로 제한됩니다.
* - 메모리에 할당된 저장공간도 블록이 끝나면 자동으로 회수되어 더 이상 존재하지 않습니다.
*/
// 지역 변수를 블록 안에 사용하는 예를 살펴 보겠습니다.
// 예제2) 블록 안에 지역 변수를 상요해 두 변수를 교환하는 프로그램
// int main()
// {
// 	int a = 10, b = 20;
// 	printf("교환 전 a와 b의 값 : %d, %d\n", a, b);
// 	{  // 블록 시작
// 		int temp;	// temp 변수 선언
// 
// 		temp = a;
// 		a = b;      //  a와 b는 5행에 선언된 변수
// 		b = temp;
// 
// 	}  // 블록 끝
// 	printf("교환 후 a와 b의 값 : %d, %d\n", a, b);
// 
// 	return 0;
// }
// 결과 : 교환 전 a와 b의 값 : 10, 20
//       교환 후 a와 b의 값 : 20, 10
/* 부가 설명
* 9행에 선언된 변수 temp는 8행과 14행의 블록 안에 선언된 지역 변수 이므로 사용 범위가 그 블록 내부로 제한됩니다.
* 메모리에 할당된 저장 공간도 14행에서 회수되므로 15행 이후에는 temp를 사용할 수 없습니다. 반면, 5행에 선언된 지역 변수 a와 b는
* main 함수 블록 어디서든 사용할 수 있으므로 main 함수에 포함되어 있는 8 ~ 14행 블록 안에서 얼마든지 사용할 수 있습니다.
* 다만 블록이 중첩된 경우 주의할 규칙이 있습니다.
*/

/* 지역 변수의 규칙
* 2. 사용 가능한 변수가 둘 이상이면 가장 가까운 블록에 선언된 변수를 사용합니다.
* - 예를 들어 예제2)의 9행에 새로운 변수 a,b를 선언하면 8~14행 블록 안에서는 5행에 선언된 변수 a와 b대신
* 가까운 블록에 선언된 9행의 변수 a와 b를 사용합니다. 안쪽 블록에서 선언된 변수a와 b는 메모리에 독립된 저장 공간을 가지므로 안쪽 블록에서
* a나 b값을 바꾸어도 5행의 변수 a와 b값에는 변함이 없습니다. 그리고 안쪽 블록에서 선언된 변수는 블록이 끝나면 저장 공간이 회수되어 더 이상
* 사용할 수 없으므로 결국 15행에서 a,b를 출력하면 바뀌지 안흥ㄴ 5행의 변수 a,b의 값이 출력됩니다.
*
* Tip!)
* 특정 블록 안에 변수를 선언하면 필요한 경우 잠깐 사용하고 메모리를 재활용하는 효과를 볼 수 있습니다.
* 즉, 두 변수 a,b의 값을 바꾸는데 사용할 임시 변수는 블록 안에서만 피룡하므로 블록안에 변수를 선언해
* 잠깐 사용하는 것이 메모리 관리에 도움이 될 수 있습니다. 그러나 중첩된 블록에서 같은 이름의 변수를 선언하면
* 예상치 못한 결과를 얻을 수 있으므로 지양해야 합니다.
* - 지역 변수가 사용한 메모리는 블록이 끝나면 동시에 반환된다 -
*/

#pragma endregion



#pragma endregion

#pragma region 전역 변수란?
/* 전역 변수란??
* 함수 밖에 변수를 선언하면 전역 변수가 됩니다. 전역 변수(global variable)는 특정 함수의 블록에 포함되지 않으므로
* 사용 범위가 함수나 블록으로 제한되지 않습니다.
* 전역 변수의 사용 범위는 프로그램 전체이므로 어떤 함수라도 안에서 직접 쓸 수 있습니다.
* - 전역 변수를 프로그램 어디에서나 사용할 수 있다 -
*/

// 예제를 통해 좀 더 구체적인 특징을 살펴보겠습니다.
// 예제3) 전역 번수의 사용 
// void assign10(void);
// void assign20(void);
// 
// int a;    // 전역 변수 선언
// 
// int main(void)
// {
// 	printf("함수 호출 전 a값 : %d\n", a);  // 전역 변수 a 출력
// 	
// 	assign10();
// 	assign20();
// 
// 	printf("함수 호출 후 a값 : %d\n", a);  // 전역 변수 a 출력
// 
// 	return 0;
// }
// void assign10(void)
// {
// 	a = 10;    // 전역 변수 a에 10 대입
// }
// void assign20(void)
// {
// 	int a;   // 전역 변수와 같은 이름의 지역 변수 선언
// 	a = 20;  // 지역 변수 a에 20 대입
// }

// 결과 : 함수 호출 전 a값 : 0
//      : 함수 호출 후 a값 : 10

/* 부가설명 
* 예제3)의 6행이 전역 변수를 선언한 부분입니다. 함수 밖에 변수를 선언하면 전역 변수가 되며 특별한 예약어는
* 사용하지 않습니다. 전역 변수는 특정 함수 안에 있는 것이 아니므로 저장 공간이 
* 메모리에 존재하는 기간이 지역변수 보다 훨씬 깁니다.
* 프로그램이 실행될 때 메모리에 할당되고 프로그램이 끝날 때가지 존재합니다.
* 따라서 전역 변수를 선언한 위치인 6행부터 그아래에 정의된 main, assign10, assign20
* 3개의 함수 안에서 모두 사용할 수 있습니다.
* - 전역 변수는 프로그램 시작과 동시에 할당되어 종료시까지 존재한다 -
* 10행에서 처음 a를 출력하는데, 실행결과를 보면 전역 변수의 초기화 여부를 알수 있습니다.
* 전역 변수는 이를 특별한 값을 초기화하지 않아도 0으로 자동으로 초기화됩니다.
* - 지역 변수는 자동 초기화가 되지 않으나 전역 변수는 0으로 자동 초기화 된다 -
* 예시)
* printf("함수 호출 전 a값 : %d\n", a);  // 10행 전역 변수 a 출력.
*/

/* 전역 변수와 같은 이름의 지역 변수
* assign10 함수가 호출되면 22행에서 a가 10으로 바뀝니다. 그리고 이어서 assign20 함수가 호출되어 29행에서
* a에 20을 대입하지만, 전역 변수 a는 바뀌지 않습니다. assign20 함수 안에 전역 변수 a와 같은 이름의
* 지역 변수가 있기 때문입니다.
* 
* 전역 변수와 지역 변수의 이름이 같으면 지역 변수를 먼저 사용합니다. 즉 27행에 선언된 지역 변수는 같은 이름의
* 전역 변수보다 먼저 사용되므로 그 값이 20으로 바뀌며 전역 변수 a에는 변화가 없습니다. 따라서 함수가 반환되고
* 난 후 15행에서 전역 변수 a에는 assign10에서 저장한 값ㅇ 10이 그대로 남아 있게 됩니다.
* 예시)
* int a;  <- 전역 변수로 선언 ------
* ------                          |
* ------                          |
*                                 |
* assign20함수()                  |  <- 같은 이름의 지역 변수 a가 있어서 전역 변수 
* {                               |     a를 사용할 수 없는 구간
* int a; <- 지역 변수로 선언------ |
*                               | |
*                               ↓ ↓
* }
*/

/* 전역 변수의 문제점
* 전역 변수의 문제점?
* - 전역 변수는 모든 함수에서 자유롭게 접근할 수 있으므로 같은 변수를 여러 함수에서 쉽게 공유할 수 있습니다.
* 그러나 이런 특징은 장점보다 부작용이 더 크므로 사용을 꺼리는 이유가 됩니다. 전역 변수의 문제점을 간단히 정리해 보겠습니다.
* 
* 1. 전역 변수의 이름을 바꾸면 그 변수를 사용하는 모든 함수를 찾아 수정해야 합니다.
* 2. 전역 변수의 값이 잘못된 경우 접근 가능한 모든 함수를 의심해야 합니다.
* 3. 코드 블록 내에 같은 이름의 지역 변수를 선언하면 거기서는 전역 변수를 사용할 수 없습니다.
* 
* 결론 : 결국 사용 범위가 명확하고 통제 가능한 지역 변수를 우선적으로 사용하고, 
* 많은 함수에서 수시로 데이터를 공유하는 경우에만 제한적으로 전역 변수를 사용하는 것이 좋습니다.
* - 전역 변수를 제한적으로 사용하거나 사용하지 않는 게 좋다 -
*/



#pragma endregion

#pragma region 정적 지역 변수란?
/* 정적 지역 변수란?
* 지역 변수를 선언할 때 static 예약어를 사용하면 정적 지역 변수 (static variable) 가 됩니다. 정적 지역 변수는
* 코드 블록 안에 선언하므로 일반 지역 변수와 같이 사용 범위가 블록 내부로 제한됩니다. 
* 반면에 저장 공간이 메모리에 존재하는 기간이 다릅ㄴ디ㅏ.
* 
* 정적 지역 변수는 선언된 함수가 반환되더라도 그 저장 공간을 계속 유지 합니다. 따라서
* 하나의 함수가 여러 번 호출되는 경우 같은 변수를 공유하는것이 가능합니다.
* - 정적 지역 변수의 저장 공간은 프로그램이 실행되는 동안 계속 유지된다 -
*/
// 일반 지역 변수와 정적 지역 변수의 차이를 예제를 통해 비교해 보겠습니다.
// 
// 예제4) auto 지역 변수와 static 지역 변수의 비교
// 
// void auto_func(void);    // auto_func 함수 선언
// void static_func(void);  // static_func 함수 선언
// 
// int main()
// {
// 	int i;
// 
// 	printf("일반 지역 변수(auto)를 사용한 함수...\n");
// 	for (i = 0; i < 3; i++)
// 	{
// 		auto_func();
// 	}
// 
// 	printf("정적 지역 변수(static)를 사용한 함수...\n");
// 	for (i = 0; i < 3; i++)
// 	{
// 		static_func();
// 	}
// 
// 	return 0;
// }
// 
// void auto_func(void)
// {
// 	auto int a = 0;     // 지역 변수 선언과 초기화
// 
// 	a++;                // a 값 1 증가
// 	printf("%d\n", a);  // a 출력
// }
// void static_func(void)
// {
// 	static int a;       // 정적 지역 변수 선언
// 
// 	a++;                // a 값 1 증가
// 	printf("%d\n", a);  // a 출력
// }
/* 결과 : 일반 지역 변수(auto)를 사용한 함수...
*  1
*  1
*  1
*   정적 지역 변수(static)를 사용한 함수...
*  1
*  2
*  3
*/

/* 부가 설명
* 먼저 예제4) 25행에 정의된auto_func 함수는 27행에서 지역 변수 a를 선언하고 0으로 초기화 됩니다.
* 지역 변수는 함수가 호출될 때 메모리에 할당되고 반환될 때 메모리에서 제거 되므로 변수 a는 auto_func함수가
* 호출될 때마다 메모리에 새롭게 할당되고 그때마다 0으로 초기화됩니다. 그 값을 29행에서 1 증가 시키고 출력하므로
* 함수의 호출 횟수와 관계없이 a는 항상 1이 출력됩니다. 13행의 반복문 안에서 auto_func 함수는 세번 호출되지만,
* 실행 결과는 모두 1이 출력된 것을 알 수 있습니다.
* 
* 반면에 예제4) 35행 처럼 지역 변수에 static 예약어를 사용하면 저장 공간이 할당되어 유지되는 시점이 함수 호출과는
* 무관해집니다. static을 사용한 정적 지역 변수는 프로그램이 실행될 때 메모리에 할당되며 프로그램이 끝날 때까지 존재합니다.
* 또한 정적 지역 변수는 초기화하지 않으면 0으로 자동 초기화 됩니다.
* 
* 예제4) 33행의 static_func 함수의 구현을 살펴 보겠습니다. 예제4)35행에 선언된 정적 지역 변수는 비록 static_func 함수
* 안에 선언되었지만, 저장공간의 할당이나 초기화 방법, 메모리 존재 기간이 전역 변수와 같습니다. 결국 정적 지역 변수는
* 선언된 블록 안에서만 사용되는 전역 변수와 같습니다.
* 예시)
* 33행 ~ 39행        <-----
* void static_func(void)  |
* {                       | = 함수 밖에 있다면?
*   static int a ---------    저장공간의 할당과 회수는 함수의 호출 및 반환과 관계가 없습니다!
*   a++;
*   printf("%d\n", a);
* }
* 
* 정적 지역 변수는 함수가 반환되더라도 저장 공간이 계속 유지되므로 함수에 필요한 값을 보관해 호출할 때마다
* 계속 사용할 수 있습니다. 실행결과를 보면 35행에 선언된 a값은 최초 0으로 자동 초기화된 후 함수가 호출될 때마다
* 37행에서 1씩 증가하므로 결국 1부터 3까지 차레로 출력됩니다. 정적 지역 변수는 프로그램이 끝날 때까지 저장 공간을 유지하면서
* 특정 함수에서만 쓰는 경우 유용합니다.
*/

#pragma endregion

#pragma region 레지스터 변수
/* 레지스터 변수란?
* 레지스터 변수 (register variable)는 블록 혹은 함수 내에 변수를 선언할 때 register 예약어를 사용합니다.
* 그렇다면 지역 변수와 레저스터 변수의 차이는 무엇일까요? 레지스터 변수의 가장 큰 특징은 저장 공간이 할당되는 위치에 있습니다.
* 이름과 같이 레지스터 변수는 CPU 안에 있는 저장 공간인 레지스터를 사용합니다.
* 레지스터는 CPU 안에 있어 데이터 처리 속도가 가장 빠른 저장 공간입니다. 따라서 반복문에 쓰는 변수와 같이 사용 횟수가 많은 경우
* 레지스터에 할당하면 실행 시간을 줄일 수 있습니다.
*/
// 예제 5) 레지스터 변수를 반복문에 사용한 예
// int main()
// {
// 	register int i;      // 레지스터 변수 선언
// 	auto int sum = 0;    // auto 지역 변수
// 
// 	for (i = 0; i <= 10000; i++)  // 반복과정에서 i를 계속 사용함
// 	{
// 		sum += i;                 // i 값을 반복해서 누적
// 	}
// 
// 	printf("레지스터 변수 i 의 값 : %d\n", sum);
// 
// 	return 0;
// }
// 결과 : 50005000
/* 부가 설명
* 8행의 반복문이 실행되면 i를 비교하고 증가시키는 작업을 계속 반복합니다. 또한 10행에서도 i를 사용하므로 i를
* 사용하는 횟수는 반복 횟수보다 3배 이상 많습니다.
* 
* 이렇게 자주 사용하는 변수를 레지스터 변수로 선언하면 변수의 데이터 처리 속도가 램 메모리에 있을 때보다 빨라 
* 프로그램 실행 시간을 줄일 수 있습니다. 메인 메모리에 있는 일반 변수의 값은 레지스터로 옮겨진 후 연산 장치에 사용됩니다.
* 따라서 레지스터에 값을 저장하면 메인 메모리에 접근하는 시간을 줄일 수 있습니다.
*/

/* 레지스터 변수 사용시 주의점
* 1. 전역변수는 레지스터 변수로 선언할 수 없습니다. 
* 이유 : 레지스터 변수는 CPU의 자원을 잠깐 빌리는 것이므로 프로그램을 실행하는 동안 계속 저장 공간을 
확보해야 하는 전역 변수는 레지스터에 할당할 수 없습니다.

* 2. 레지스터 변수는 주소를 구할 수 업습니다.
* 이유 : 레지스터 변수는 저장 공간이 메모리에 있는 것이 아니므로 주소 연산자를 써서 주소를 구할 수 없습니다.
* 
* 3. 레지스터의 사용 여부는 컴파일러가 결정합니다.
* 이유 : 재미있게도 레지스터 변수를 선언했다고 모두 레지스터에 변수가 생성되는 것은 아닙니다. 레지스터는 CPU의 연산장치가 사용하는
* 비싸고 중요한 저장 공간이므로 당장 연산할 필요가 없는 데이터를 레지스터에 보관하면 레지스터의 활용성이 떨어집니다. 
* 따라서 컴파일러는 사용자가 레지스터 변수를 선언하더라도 레지스터와 메모리 중에 어디에 할당하는 것이 더 이득인지 판단해 
* 적당한 저장 공간을 선택합니다.
* - 레지스터 변수의 생성 위치는 컴파일러가 상황에 따라 정한다 -
*/
#pragma endregion

#pragma region (4)가지 키워드로 끝내는 핵심 포인트
/*
* 1. 지역 변수의 사용 범위는 블록으로 제한된다.
* 2. 지역 변수와 젼역 변수의 사용 범위가 겹치면 지역 변수를 먼저 사용한다.
* 3. 지역 변수에 static을 사용해서 정적 지역 변수로 만들면 프로그램의 시작부터 종료까지 저장공간이 유지된다.
* 4. 레지스터 변수는 컴파일러가 레지스터에 생성할지 말지를 결정한다.
* 
* ※ 표로 정리하는 핵심 포인트 ※
* ---------------------------------------------------------------------------------------------
* |      종류       |               지역 변수               |             전역변수              |
* | 예약어          |   auto   |   register   |   static   |         없음         |   static   |
* | 선언 위치       |             코드 블록 내부            |              함수외부              |
* | 사용 범위	   |         선언 ~ 선언한 블록 끝          |  프로그램 전체  |  하나의 파일 내부 |
* | 메모리 존재 기간 |   선언 ~ 선언한 블록 끝  |              프로그램 시작 ~ 종료               |
* | 자동 초기화	    |           없음          |              0으로 자동으로 초기화              |
* | 메모리 위치	    | 스택영역 |   레지스터    |                   데이터 영역                  |
* ---------------------------------------------------------------------------------------------
* 부가 설명
* 전역 변수에 static을 사용하는 정적 전역 변수와 전역 변수에 대한 extern 선언은 아직 다루지 않았습니다.
* 이들은 분할 컴파일과 관련된 내용이므로 19장에서 다룹니다.
*/

#pragma endregion
