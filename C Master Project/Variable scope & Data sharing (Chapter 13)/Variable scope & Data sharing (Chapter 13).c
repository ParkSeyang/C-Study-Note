#include <stdio.h>

#pragma region 변수 사용 영역 
/* Chapter 13에서 배울것들
* ※ 지역 변수
* ※ 전역 변수
* ※ 정적 지역 변수
* ※ 레지스터 변수
* Chapter 13에서 배울것들 
* 프로그램에서 사용하는 변수는 선언 위치와 방법에 따라 다양한 특징을 가집니다.
* 변수의 특징을 이해하고 필요한 곳에 정확히 사용하면 메모리를 절약하고 신뢰성있는 코드를 만들 수 있습니다.
* 이 절에서는 변수명의 사용 범위와 저장 공간이 할당되는 방식 따라 변수를 나누고 그 특징을 살펴봅니다.
* 
* 이미 Chapter 3에서 변수를 배웠고 지금까지 계속 사용해 왔습니다. 사실 따로 언급하지 않았던 부분이 있는데,
* 지금까지 우리가 사용한 변수는 대부분 지역 변수였습니다. 단순히 "자료형 변수명;" 으로 선언했던것도 사실은
* 지역 변수를 뜻하는 auto라는 예약어가 생략된 문자이었죠. 이밖에도 전역 변수, 레지스터 변수등 변수의 종류는 다양합니다.
* 예시)
* auto 자료형 변수명;
*/
#pragma region 지역 변수란?
/* 지역 변수란?
* 지금까지 사용했던 변수는 지역 변수 (local variable)입니다. 지역 변수는 범위가 함수 내, 즉 일정 지역에서만 사용하는
* 변수입니다. 본래 auto 예약어와 함께 함수 안에 지역 변수를 선언합니다. auto 예약어는 생략할 수 있으며 이 경우 함수 안에
* 선언된 변수는 자동으로 지역 변수가 됩니다.
* Note
* - 지역 변수와 자동 변수(auto variable)는 같은 용어입니다. 지역 변수는 기억 부류 중 하나입니다. 기억 부류(storage class)는
* 변수를 사용 범위와 메모리에서의 존재 기간에 따라 나눈 것입니다. 따라서 지역 변수는 변수의 특성 중 사용 범위를 강조한 것이며
* 자동 변수는 지역 분수가 auto 예약어를 사용하므로 쓰는 용어입니다.
*
* 지역 변수의 특징
* 1.지역 변수는 사용 범위가 블록 내부로 제한되므로 다른 함수에서는 사용할 수 없습니다.
* - 따라서 다른 함수에 같은 이름의 변수를 선언해도 이름이 서로 충돌하지 않습니다.
* 간단한 예제를 통해 확인해보겠습니다.
*/
// 예제 1번) 두 함수에서 같은 이름의 지역 변수를 사용한 경우
// void assign(void);  // 함수 선언
// 
// int main()
// {
// 	auto int a = 0; // 지역 변수 선언과 초기화, auto는 생략 가능
// 
// 	assign();       // 함수 호출;
// 	printf("main 함수 a : %d\n", a);
// 	
// 	return 0;
// }
// 
// void assign(void)
// {
// 	int a;								 // main 함수에 있는 변수와 같은 이름의 지역 변수, auto 생략
// 
// 	a = 10;								 // assign 함수 안에 선언된 a에 대입
// 	printf("assign 함수 a : %d \n", a);  // assign 함수에 선언된 a값 출력
// }
// 결과 : assign 함수 a : 10
//		  main 함수 a : 0

/* 예제1) 의 부가설명
*  이 프로그램에는 7행과 17행에 같은 이름의 변수를 두 번 선언했지만, 함수가 다르므로 문제가 되지 않습니다.
* 7행의 변수 a는 사용 범위가 main 함수의 블록으로 제한되므로 assign 함수에서 사용할수 없고 17행의 assign 함수안의 변수 a도 main함수에서
* 사용할 수 없기 때문입니다. 따라서 19행에서 a에 10을 대입할 때 컴파일러는 고민하지 않고 assign 함수에 선언된 변수 a를 사용합니다.
* 만약 assign 함수에 변수 a의 선언문이 없다면 19행과 20행에서 a의 정체를 알 수 없으므로 컴파일 에러가 발생합니다.
*/

/* 지역 변수의 특징
* 2. 지역 변수는 이름이 같아도 선언된 함수가 다르면 각각 독립된 저장 공간을 갖습니다.
* - 즉 두함수에 선언된 변수a는 이름만 같을 뿐 메모리에 별도의 저장 공간을 갖습니다. 따라서 assign 함수가 호출된
* 이후에도 main 함수에 있는 a의 값은 바뀌지 않습니다.
*
* 지역 변수 사용의 장점
*
* 1. 메모리를 효율적으로 사용합니다.
* - 지역 변수는 함수 안에서만 사용하므로 함수가 반환되면 그 저장 공간을 계속 유지할 필요가 없습니다.
* 따라서 운영체제는 지역 변수가 선언된 함수가 반환되면 할당된 저장 공간을 자동으로 회수해 재활용합니다.
*
* 2. 디버깅에 유리합니다.
* - 지역 변수는 값에 문제가 있을 때 수정하기 쉽습니다. 예를 들어 10행 에서 출력한 a의 값이 예상한 값이 아닌 경우 a가 선언된 main 함수에서만
* 그 원인을 찾으면 됩니다.
* 그런데 지역 변수가 할당된 저장 공간은 자동으로 초기화되지 않으므로 쓰레기 값이 사용되지 않도록 주의 해야합니다.
* 또한 사용 범위가 하나의 함수로 제한되므로 2개 이상의 함수에서 데이터를 공유하기가 쉽지 않습니다. 그러나 이런 불편함보다
* 장점이 더 크므로 다른 종류의 변수보다 지역 변수를 최우선으로 사용해야 합니다.
*
* Tip!)
* 함수의 매개변수는 지역 변수입니다.
* 함수를 만들 때 괄호 안에 선언하는 매개변수는 호출할 대 전달되는 값을 받기 위해 특별한 위치에 선언하는 것일 뿐
* 사용 범위나 메모리에 존재하는 기간 등 변수가 갖는 모든 특징은 지역 변수와 같습니다.
*/

/* 블록 안에서 사용하는 지역 변수
* 지역 변수는 보통 함수 안에서 선언된 후 함수 끝까지 사용되지만, 선언 위치에 따라 사용 범위가 달라질 수 있습니다.
* 지역 변수의 규칙
* 1. 특정 블록 안에 변수를 선언하면 사용 범위가 블록 내부로 제한됩니다.
* - 메모리에 할당된 저장공간도 블록이 끝나면 자동으로 회수되어 더 이상 존재하지 않습니다.
*/
// 지역 변수를 블록 안에 사용하는 예를 살펴 보겠습니다.
// 예제2) 블록 안에 지역 변수를 상요해 두 변수를 교환하는 프로그램
// int main()
// {
// 	int a = 10, b = 20;
// 	printf("교환 전 a와 b의 값 : %d, %d\n", a, b);
// 	{  // 블록 시작
// 		int temp;	// temp 변수 선언
// 
// 		temp = a;
// 		a = b;      //  a와 b는 5행에 선언된 변수
// 		b = temp;
// 
// 	}  // 블록 끝
// 	printf("교환 후 a와 b의 값 : %d, %d\n", a, b);
// 
// 	return 0;
// }
// 결과 : 교환 전 a와 b의 값 : 10, 20
//       교환 후 a와 b의 값 : 20, 10
/* 부가 설명
* 9행에 선언된 변수 temp는 8행과 14행의 블록 안에 선언된 지역 변수 이므로 사용 범위가 그 블록 내부로 제한됩니다.
* 메모리에 할당된 저장 공간도 14행에서 회수되므로 15행 이후에는 temp를 사용할 수 없습니다. 반면, 5행에 선언된 지역 변수 a와 b는
* main 함수 블록 어디서든 사용할 수 있으므로 main 함수에 포함되어 있는 8 ~ 14행 블록 안에서 얼마든지 사용할 수 있습니다.
* 다만 블록이 중첩된 경우 주의할 규칙이 있습니다.
*/

/* 지역 변수의 규칙
* 2. 사용 가능한 변수가 둘 이상이면 가장 가까운 블록에 선언된 변수를 사용합니다.
* - 예를 들어 예제2)의 9행에 새로운 변수 a,b를 선언하면 8~14행 블록 안에서는 5행에 선언된 변수 a와 b대신
* 가까운 블록에 선언된 9행의 변수 a와 b를 사용합니다. 안쪽 블록에서 선언된 변수a와 b는 메모리에 독립된 저장 공간을 가지므로 안쪽 블록에서
* a나 b값을 바꾸어도 5행의 변수 a와 b값에는 변함이 없습니다. 그리고 안쪽 블록에서 선언된 변수는 블록이 끝나면 저장 공간이 회수되어 더 이상
* 사용할 수 없으므로 결국 15행에서 a,b를 출력하면 바뀌지 안흥ㄴ 5행의 변수 a,b의 값이 출력됩니다.
*
* Tip!)
* 특정 블록 안에 변수를 선언하면 필요한 경우 잠깐 사용하고 메모리를 재활용하는 효과를 볼 수 있습니다.
* 즉, 두 변수 a,b의 값을 바꾸는데 사용할 임시 변수는 블록 안에서만 피룡하므로 블록안에 변수를 선언해
* 잠깐 사용하는 것이 메모리 관리에 도움이 될 수 있습니다. 그러나 중첩된 블록에서 같은 이름의 변수를 선언하면
* 예상치 못한 결과를 얻을 수 있으므로 지양해야 합니다.
* - 지역 변수가 사용한 메모리는 블록이 끝나면 동시에 반환된다 -
*/

#pragma endregion



#pragma endregion

#pragma region 전역 변수란?
/* 전역 변수란??
* 함수 밖에 변수를 선언하면 전역 변수가 됩니다. 전역 변수(global variable)는 특정 함수의 블록에 포함되지 않으므로
* 사용 범위가 함수나 블록으로 제한되지 않습니다.
* 전역 변수의 사용 범위는 프로그램 전체이므로 어떤 함수라도 안에서 직접 쓸 수 있습니다.
* - 전역 변수를 프로그램 어디에서나 사용할 수 있다 -
*/

// 예제를 통해 좀 더 구체적인 특징을 살펴보겠습니다.
// 예제3) 전역 번수의 사용 
// void assign10(void);
// void assign20(void);
// 
// int a;    // 전역 변수 선언
// 
// int main(void)
// {
// 	printf("함수 호출 전 a값 : %d\n", a);  // 전역 변수 a 출력
// 	
// 	assign10();
// 	assign20();
// 
// 	printf("함수 호출 후 a값 : %d\n", a);  // 전역 변수 a 출력
// 
// 	return 0;
// }
// void assign10(void)
// {
// 	a = 10;    // 전역 변수 a에 10 대입
// }
// void assign20(void)
// {
// 	int a;   // 전역 변수와 같은 이름의 지역 변수 선언
// 	a = 20;  // 지역 변수 a에 20 대입
// }

// 결과 : 함수 호출 전 a값 : 0
//      : 함수 호출 후 a값 : 10

/* 부가설명 
* 예제3)의 6행이 전역 변수를 선언한 부분입니다. 함수 밖에 변수를 선언하면 전역 변수가 되며 특별한 예약어는
* 사용하지 않습니다. 전역 변수는 특정 함수 안에 있는 것이 아니므로 저장 공간이 
* 메모리에 존재하는 기간이 지역변수 보다 훨씬 깁니다.
* 프로그램이 실행될 때 메모리에 할당되고 프로그램이 끝날 때가지 존재합니다.
* 따라서 전역 변수를 선언한 위치인 6행부터 그아래에 정의된 main, assign10, assign20
* 3개의 함수 안에서 모두 사용할 수 있습니다.
* - 전역 변수는 프로그램 시작과 동시에 할당되어 종료시까지 존재한다 -
* 10행에서 처음 a를 출력하는데, 실행결과를 보면 전역 변수의 초기화 여부를 알수 있습니다.
* 전역 변수는 이를 특별한 값을 초기화하지 않아도 0으로 자동으로 초기화됩니다.
* - 지역 변수는 자동 초기화가 되지 않으나 전역 변수는 0으로 자동 초기화 된다 -
* 예시)
* printf("함수 호출 전 a값 : %d\n", a);  // 10행 전역 변수 a 출력.
*/

/* 전역 변수와 같은 이름의 지역 변수
* assign10 함수가 호출되면 22행에서 a가 10으로 바뀝니다. 그리고 이어서 assign20 함수가 호출되어 29행에서
* a에 20을 대입하지만, 전역 변수 a는 바뀌지 않습니다. assign20 함수 안에 전역 변수 a와 같은 이름의
* 지역 변수가 있기 때문입니다.
* 
* 전역 변수와 지역 변수의 이름이 같으면 지역 변수를 먼저 사용합니다. 즉 27행에 선언된 지역 변수는 같은 이름의
* 전역 변수보다 먼저 사용되므로 그 값이 20으로 바뀌며 전역 변수 a에는 변화가 없습니다. 따라서 함수가 반환되고
* 난 후 15행에서 전역 변수 a에는 assign10에서 저장한 값ㅇ 10이 그대로 남아 있게 됩니다.
* 예시)
* int a;  <- 전역 변수로 선언 ------
* ------                          |
* ------                          |
*                                 |
* assign20함수()                  |  <- 같은 이름의 지역 변수 a가 있어서 전역 변수 
* {                               |     a를 사용할 수 없는 구간
* int a; <- 지역 변수로 선언------ |
*                               | |
*                               ↓ ↓
* }
*/

/* 전역 변수의 문제점
* 전역 변수의 문제점?
* - 전역 변수는 모든 함수에서 자유롭게 접근할 수 있으므로 같은 변수를 여러 함수에서 쉽게 공유할 수 있습니다.
* 그러나 이런 특징은 장점보다 부작용이 더 크므로 사용을 꺼리는 이유가 됩니다. 전역 변수의 문제점을 간단히 정리해 보겠습니다.
* 
* 1. 전역 변수의 이름을 바꾸면 그 변수를 사용하는 모든 함수를 찾아 수정해야 합니다.
* 2. 전역 변수의 값이 잘못된 경우 접근 가능한 모든 함수를 의심해야 합니다.
* 3. 코드 블록 내에 같은 이름의 지역 변수를 선언하면 거기서는 전역 변수를 사용할 수 없습니다.
* 
* 결론 : 결국 사용 범위가 명확하고 통제 가능한 지역 변수를 우선적으로 사용하고, 
* 많은 함수에서 수시로 데이터를 공유하는 경우에만 제한적으로 전역 변수를 사용하는 것이 좋습니다.
* - 전역 변수를 제한적으로 사용하거나 사용하지 않는 게 좋다 -
*/



#pragma endregion

#pragma region 정적 지역 변수란?
/* 정적 지역 변수란?
* 지역 변수를 선언할 때 static 예약어를 사용하면 정적 지역 변수 (static variable) 가 됩니다. 정적 지역 변수는
* 코드 블록 안에 선언하므로 일반 지역 변수와 같이 사용 범위가 블록 내부로 제한됩니다. 
* 반면에 저장 공간이 메모리에 존재하는 기간이 다릅ㄴ디ㅏ.
* 
* 정적 지역 변수는 선언된 함수가 반환되더라도 그 저장 공간을 계속 유지 합니다. 따라서
* 하나의 함수가 여러 번 호출되는 경우 같은 변수를 공유하는것이 가능합니다.
* - 정적 지역 변수의 저장 공간은 프로그램이 실행되는 동안 계속 유지된다 -
*/
// 일반 지역 변수와 정적 지역 변수의 차이를 예제를 통해 비교해 보겠습니다.
// 
// 예제4) auto 지역 변수와 static 지역 변수의 비교
// 
// void auto_func(void);    // auto_func 함수 선언
// void static_func(void);  // static_func 함수 선언
// 
// int main()
// {
// 	int i;
// 
// 	printf("일반 지역 변수(auto)를 사용한 함수...\n");
// 	for (i = 0; i < 3; i++)
// 	{
// 		auto_func();
// 	}
// 
// 	printf("정적 지역 변수(static)를 사용한 함수...\n");
// 	for (i = 0; i < 3; i++)
// 	{
// 		static_func();
// 	}
// 
// 	return 0;
// }
// 
// void auto_func(void)
// {
// 	auto int a = 0;     // 지역 변수 선언과 초기화
// 
// 	a++;                // a 값 1 증가
// 	printf("%d\n", a);  // a 출력
// }
// void static_func(void)
// {
// 	static int a;       // 정적 지역 변수 선언
// 
// 	a++;                // a 값 1 증가
// 	printf("%d\n", a);  // a 출력
// }
/* 결과 : 일반 지역 변수(auto)를 사용한 함수...
*  1
*  1
*  1
*   정적 지역 변수(static)를 사용한 함수...
*  1
*  2
*  3
*/

/* 부가 설명
* 먼저 예제4) 25행에 정의된auto_func 함수는 27행에서 지역 변수 a를 선언하고 0으로 초기화 됩니다.
* 지역 변수는 함수가 호출될 때 메모리에 할당되고 반환될 때 메모리에서 제거 되므로 변수 a는 auto_func함수가
* 호출될 때마다 메모리에 새롭게 할당되고 그때마다 0으로 초기화됩니다. 그 값을 29행에서 1 증가 시키고 출력하므로
* 함수의 호출 횟수와 관계없이 a는 항상 1이 출력됩니다. 13행의 반복문 안에서 auto_func 함수는 세번 호출되지만,
* 실행 결과는 모두 1이 출력된 것을 알 수 있습니다.
* 
* 반면에 예제4) 35행 처럼 지역 변수에 static 예약어를 사용하면 저장 공간이 할당되어 유지되는 시점이 함수 호출과는
* 무관해집니다. static을 사용한 정적 지역 변수는 프로그램이 실행될 때 메모리에 할당되며 프로그램이 끝날 때까지 존재합니다.
* 또한 정적 지역 변수는 초기화하지 않으면 0으로 자동 초기화 됩니다.
* 
* 예제4) 33행의 static_func 함수의 구현을 살펴 보겠습니다. 예제4)35행에 선언된 정적 지역 변수는 비록 static_func 함수
* 안에 선언되었지만, 저장공간의 할당이나 초기화 방법, 메모리 존재 기간이 전역 변수와 같습니다. 결국 정적 지역 변수는
* 선언된 블록 안에서만 사용되는 전역 변수와 같습니다.
* 예시)
* 33행 ~ 39행        <-----
* void static_func(void)  |
* {                       | = 함수 밖에 있다면?
*   static int a ---------    저장공간의 할당과 회수는 함수의 호출 및 반환과 관계가 없습니다!
*   a++;
*   printf("%d\n", a);
* }
* 
* 정적 지역 변수는 함수가 반환되더라도 저장 공간이 계속 유지되므로 함수에 필요한 값을 보관해 호출할 때마다
* 계속 사용할 수 있습니다. 실행결과를 보면 35행에 선언된 a값은 최초 0으로 자동 초기화된 후 함수가 호출될 때마다
* 37행에서 1씩 증가하므로 결국 1부터 3까지 차레로 출력됩니다. 정적 지역 변수는 프로그램이 끝날 때까지 저장 공간을 유지하면서
* 특정 함수에서만 쓰는 경우 유용합니다.
*/

#pragma endregion

#pragma region 레지스터 변수
/* 레지스터 변수란?
* 레지스터 변수 (register variable)는 블록 혹은 함수 내에 변수를 선언할 때 register 예약어를 사용합니다.
* 그렇다면 지역 변수와 레저스터 변수의 차이는 무엇일까요? 레지스터 변수의 가장 큰 특징은 저장 공간이 할당되는 위치에 있습니다.
* 이름과 같이 레지스터 변수는 CPU 안에 있는 저장 공간인 레지스터를 사용합니다.
* 레지스터는 CPU 안에 있어 데이터 처리 속도가 가장 빠른 저장 공간입니다. 따라서 반복문에 쓰는 변수와 같이 사용 횟수가 많은 경우
* 레지스터에 할당하면 실행 시간을 줄일 수 있습니다.
*/
// 예제 5) 레지스터 변수를 반복문에 사용한 예
// int main()
// {
// 	register int i;      // 레지스터 변수 선언
// 	auto int sum = 0;    // auto 지역 변수
// 
// 	for (i = 0; i <= 10000; i++)  // 반복과정에서 i를 계속 사용함
// 	{
// 		sum += i;                 // i 값을 반복해서 누적
// 	}
// 
// 	printf("레지스터 변수 i 의 값 : %d\n", sum);
// 
// 	return 0;
// }
// 결과 : 50005000
/* 부가 설명
* 8행의 반복문이 실행되면 i를 비교하고 증가시키는 작업을 계속 반복합니다. 또한 10행에서도 i를 사용하므로 i를
* 사용하는 횟수는 반복 횟수보다 3배 이상 많습니다.
* 
* 이렇게 자주 사용하는 변수를 레지스터 변수로 선언하면 변수의 데이터 처리 속도가 램 메모리에 있을 때보다 빨라 
* 프로그램 실행 시간을 줄일 수 있습니다. 메인 메모리에 있는 일반 변수의 값은 레지스터로 옮겨진 후 연산 장치에 사용됩니다.
* 따라서 레지스터에 값을 저장하면 메인 메모리에 접근하는 시간을 줄일 수 있습니다.
*/

/* 레지스터 변수 사용시 주의점
* 1. 전역변수는 레지스터 변수로 선언할 수 없습니다. 
* 이유 : 레지스터 변수는 CPU의 자원을 잠깐 빌리는 것이므로 프로그램을 실행하는 동안 계속 저장 공간을 
확보해야 하는 전역 변수는 레지스터에 할당할 수 없습니다.

* 2. 레지스터 변수는 주소를 구할 수 업습니다.
* 이유 : 레지스터 변수는 저장 공간이 메모리에 있는 것이 아니므로 주소 연산자를 써서 주소를 구할 수 없습니다.
* 
* 3. 레지스터의 사용 여부는 컴파일러가 결정합니다.
* 이유 : 재미있게도 레지스터 변수를 선언했다고 모두 레지스터에 변수가 생성되는 것은 아닙니다. 레지스터는 CPU의 연산장치가 사용하는
* 비싸고 중요한 저장 공간이므로 당장 연산할 필요가 없는 데이터를 레지스터에 보관하면 레지스터의 활용성이 떨어집니다. 
* 따라서 컴파일러는 사용자가 레지스터 변수를 선언하더라도 레지스터와 메모리 중에 어디에 할당하는 것이 더 이득인지 판단해 
* 적당한 저장 공간을 선택합니다.
* - 레지스터 변수의 생성 위치는 컴파일러가 상황에 따라 정한다 -
*/
#pragma endregion

#pragma region (4)가지 키워드로 끝내는 핵심 포인트
/*
* 1. 지역 변수의 사용 범위는 블록으로 제한된다.
* 2. 지역 변수와 젼역 변수의 사용 범위가 겹치면 지역 변수를 먼저 사용한다.
* 3. 지역 변수에 static을 사용해서 정적 지역 변수로 만들면 프로그램의 시작부터 종료까지 저장공간이 유지된다.
* 4. 레지스터 변수는 컴파일러가 레지스터에 생성할지 말지를 결정한다.
* 
* ※ 표로 정리하는 핵심 포인트 ※
* ---------------------------------------------------------------------------------------------
* |      종류       |               지역 변수               |             전역변수              |
* | 예약어          |   auto   |   register   |   static   |         없음         |   static   |
* | 선언 위치       |             코드 블록 내부            |              함수외부              |
* | 사용 범위	   |         선언 ~ 선언한 블록 끝          |  프로그램 전체  |  하나의 파일 내부 |
* | 메모리 존재 기간 |   선언 ~ 선언한 블록 끝  |              프로그램 시작 ~ 종료               |
* | 자동 초기화	    |           없음          |              0으로 자동으로 초기화              |
* | 메모리 위치	    | 스택영역 |   레지스터    |                   데이터 영역                  |
* ---------------------------------------------------------------------------------------------
* 부가 설명
* 전역 변수에 static을 사용하는 정적 전역 변수와 전역 변수에 대한 extern 선언은 아직 다루지 않았습니다.
* 이들은 분할 컴파일과 관련된 내용이므로 19장에서 다룹니다.
*/

#pragma endregion

#pragma region 확인문제
/* 프로그램에서 사용하는 변수는 사용범위에 따라 간단히 지역 변수와 전역 변수로 구분합니다.
* 그러나 같은 지역 변수라도 저장공간의 유지 기간이 다른 정적 지역 변수도 있고 저장 공간이 메모리가
* 아닌 레지스터인 것도 있습니다. 이런 변수의 특성을 이해하고 적절히 사용하면 안정적이고 
* 효율적인 프로그램 을 만들수 있습니다.
* 
* 
* 1. 다음 문장에서 설명이 『틀린』 것을 모두 고르세요.
* ⑴ 지역 변수는 선언된 함수가 반환되면 할당된 저장 공간이 자동으로 회수된다.
* ⑵ 전역 변수와 정적 변수는 프로그램이 실행되는 동안 계속 저장 공간을 유지한다.
* ⑶ 정적 지역 변수와 전역 변수는 변수의 사용 범위가 같다.
* ⑷ auto를 사용한 지역 변수는 저장 공간 할당과 동시에 0으로 자동 초기화된다.
* ⑸ 하나의 함수 내에서는 같은 일므의 변수를 선언할 수 없다.
* ⑹ 전역 변수와 지역 변수는 같은 이름을 사용할 수 있으나 전역 변수에 우선권이 있다.
* 
* 정답 : ⑶, ⑷, ⑸, ⑹
* 틀린이유 : ⑶ 전역 변수의 사용범위가 더큽니다.
* 틀린이유 : ⑷ auto를 사용한 지역 변수는 자동 초기화되지 않습니다.
* 틀린이유 : ⑸ 하나의 함수 안이라도 블록을 새로 열면 같은 이름의 변수를 선언할 수 있습니다.
* 틀린이유 : ⑹ 지역 변수에 우선권이 있습니다. 
*/		

// 2. 다음 프로그램의 실행 결과를 적으세요.
// void func(void);
// 
// int a = 10;
// 
// int main()
// {
// 	a = 20;
// 	func();
// 	printf("%d", a);
// 	return 0;
// 
// }
// void func(void)
// {
// 	a = 30;
// }
/* 실행 결과 : 30
* 부가 설명 
* - a는 전역변수이므로 main함수와 func 함수에서 모두 사용할 수 있습니다. 따라서 func함수에서
* 마지막으로 대입한 30이 출력됩니다.
*/

// 3. 실행결과와 일치하도록 빈칸에 적당한 예약어를 적으세요.

// int func(void);
// 
// int main()
// {
// 	int i, sum = 0;
// 
// 	for (i = 0; i < 10; i++)
// 	{
// 		sum += func();
// 	}
// 
// 	printf("%d", sum);
// 
// 	return 0;
// }
// 
// int func(void)
// {
// 	( ★ ) int a = 0;
// 	a++;
// 	return a;
// }

/* 실행 결과 : 55
* 빈칸( ★ )의 정답 : static
* 이유 : int a에 static 예약어를 사용해서 정적 지역 변수로 만들면 프로그램의 시작부터 종료시까지
* 저장 공간이 유지 되기 때문에 a의 공간에 저장되있는 값이 유지됩니다. 그상태로 int func함수에서 a++;을하면 안에있는 값에 1식 추가되므로 
* 실행 결과 값이 55가됩니다.
* 다른방법 : int func 함수안에 int a를 지우고 전역 변수로 int a = 0;이라고 선언해도 같은결과값이 나옵니다 이유는
* 전역 변수를 선언하면 main함수와 func함수안에도 같이 사용할 수 있기 때문입니다.
*/
#pragma endregion

#pragma region 함수의 데이터 공유 방법
/* 핵심 키워드
* 값을 복사해서 전달, 주소를 전달, 주소를 반환
* 
* 시작전 설명
* - 둘 이상의 함수로 구현된 프로그램은 함수 간에 데이터를 공유하기 위해 다양한 방법을
* 사용합니다. 함수의 기능에 따라 꼭 사용해야 하는 방법도 있으나 적절한 방법을 선택하면
* 안정적이고 읽기 쉬운 프로그램을 만들 수 있습니다. 여기서는 함수간의 데이터 공유방법과
* 장단점을 살펴봅니다.
*/

// ※ 값을 복사해서 전달하는 방법 ※
/* 함수를 호출할 때 필요한 데이터를 전달하는 가장 일반적인 방법은 값을 복사해서 전달하는 것입니다.
* 이 방법은 함수를 호출할 때 변수뿐 아니라 상수나 수식도 사용할 수 있으며 지금까지 여러 차례 사용했던 방식입니다.
* 이렇게 하면 호출된 함수가 반환된 이후에도 호출한 함수에 있는 변수의 값은 변하지 않습니다. 예제를통해 무슨뜻인지
* 확인해 보겟습니다.
* -호출된 함수의 기능과 상관없이 호출한 함수의 변숫값은 그대로다.-
*/

// - 예제) 10을 더하기 위해 값을 인수로 주는 경우 - 

// void add_ten(int a);    // 함수 선언
// 
// int main()
// {
// 	int a = 10;
// 
// 	add_ten(a);         // a 값을 복사해 전달
// 	printf("a : %d\n", a);
// 	
// 	return 0;
// }
// 
// void add_ten(int a)  // 7행의 a와 다른 독립적인 저장 공간 할당
// {
// 	a = a + 10;      // 15행의 매개변수 a에 10을 더한다. 
// }

// 실행 결과 =  a : 10
/* 부가 설명
* 현재와 같이 코드를 작성하고 실행하면 10값으로 출력됩니다 그이유는 매개변수의 a의 메모리 주소에 저장된 값을 main 함수로 넘겨주지않았기
* 때문입니다. 따라서 17행에서 매개 변수 a를 증가시켜도 main 함수에 있는 a는 변함이 없습니다.
* 만약 main 함수의 변수 a를 증가하기를 원한다면 add_ten 함수가 증가시킨 값을 반환해 main 함수의 a에 다시 대입하는 방법을 사용해야합니다.
* 
* 현재 예제에서 a의값을 증가시키는방법 
* - 3, 9, 15 행을 다음처럼 수정하면 됩니다. 물론 17행의 증가한 a값을 반환하는 문장도 있어야합니다.
* 3행. 반환 값이 있는 함수로 선언
* - int add_ten(int a);
* 
* 9행. 증가한 값을 반환해 main 함수의 변수 a에 대입
* - int main()
* {
*  a = add_ten(a);
* }
* 
* 15행. 반환값이 있는 함수로 정의
* - int add_ten(int a)
* 
* 17행의 다음 행에 반환 문장 추가
* - return a;
* 
* 호출되는 함수에 값을 복사해 전달하는 방식은 값을 출력하거나 연산하는 경우 
* 또는 같이 호출하는 함수의 값을 바꿀 필요가 없는 경우에 사용합니다.
*/

/* ※ 주소를 전달하는 방법 ※
* 함수를 호출할 때 처리할 변수의 주소를 넘기는 방법도 있습니다. 이 경우 포인터 연산으로 값을 처리해야 하므로
* 값을 전달하는 방법보다 불편합니다. 하지만 호출된 함수에서 호출한 함수에 있는 변수의 값을 바꿀 수 있습니다.
* (※ 예제 10을 더하기 위해 값을 인수로 주는 경우 ※) 를 수정해 포인터로 main 함수에 있는 변수의 값을 바꿔 보겠습니다.
* - 요약 - 
* 주소를 전달하면 호출한 함수의 변숫값을 바꿀 수 있다.
*/

// 예제2) 포인터를 써서 변수의 값에 10을 더하는 경우

// void add_ten(int* pa);   // 매개변수로 포인터 pa 선언
// 
// int main()
// {
// 	int a = 10;
// 
// 	add_ten(&a);           // a의 주소를 인수로 준다.
// 	printf("a : %d\n", a); // 증가된 a 값 출력
// 
// 	return 0;
// }
// 
// void add_ten(int* pa)     // 포인터 pa 가 a의 주소를 받는다.
// {
// 	*pa = *pa + 10;       // 포인터 pa 가 가리키는 변수의 값 10 증가
// }
// 결과   
// a : 20

/* 부가 설명
* 예제2)의 9행에서 변수 a의 주소가 함수에 전달되며, 예제2)의 15행에서는 포인터를 매개변수로 선언해 받습니다.
* 따라서 예제2)의 17행에서 매개변수 pa에 간접 참조 연산자를 사용하면 main 함수에 있는 a를 사용할 수 있으며
* 그 값을 바꾸는 것도 가능해집니다.
*/

/* ※ 값을 복사해서 전달하는 방식 VS 주소를 전달하는 방식※
* 지금까지 2가지 방식으로 함수의 데이터를 공유하는 방법을 배웟습니다. 이 두방식은 각기 장단점이 있습니다.
* 
* 값을 복사해서 전달하는방식
* 장점 : 원본 데이터를 보존할 수 있으므로 안정성을 담보해야 하는 상황에 유용합니다.
* 단점 : 원본의 데이터 수정이 목적일 경우에는 사용법이 제한됩니다.
* 
* 주소를 전달하는 방식
* 장점 : 원본 데이터를 바꿀 때 유용하다.
* 단점 : 사용법이 복잡하며 절대 바꾸면 안 되는 데이터를 다룰 때 사용하면 문제가 생길 수 있습니다.
* 
* 결론 : 꼭 필요한 경우가 아니면 값을 복사해서 전달하는 방식을 기본으로 사용합니다.
*/
/* 자잘한 이야기! 
* ※ C 언어에서 call by value와 call by reference에 대한 논란 ※
* - 함수를 호출 할 때 변수의 값을 복사해 인수로 주는 방식을 call by value(값에 의한 호출)라고 합니다. 
* 반면에 call by reference(참조에 의한 호출)는 호출 함수의 변수를 피호출 함수에서 매개변수의 이름으로 직접 사용하는 방식입니다.
* 따라서 call by reference 방식을 사용하면 하나의 저장 공간을 서로 다른 함수에서 2개의 이름으로 쉽게 공유할 수 있습니다.
* 그런데 C언어에는 call by reference를 구현하는 문법 형식이 없습니다. 다만, 주소를 함수의 인수로 주고 포인터로 받아
* 간접 참조 연산을 통해 call by reference와 비슷한 효과를 낼 수 있습니다. 이 방법도 주소 값을 주고 받으므로 결국
* call by value입니다.
*/


/* ※ 주소를 반환하는 함수 ※
* 반환값이 있는 함수는 호출한 함수로 값을 복사해서 반환합니다. 함수 안에서 사용한 지역 변수는 함수가 반환되면
* 저장 공간이 사라지므로 그 값을 복사해 반환해야 호출한 함수에서 사용할 수 있습니다. 
* 그러나 함수가 반환된 후에도 변수의 저장 공간이 계속 유지된다면 주소를 반환해 호출하는 함수에서 쓸 수도 있습니다.
* 즉, 정적 지역 변수와 전역 변수는 주소를 반환할 수 있습니다. 예제를 통해 구체적으로 살펴 보겠습니다.
*/

// 예제3) 주소를 반환해서 두 정수의 합 계산

// int* sum(int a, int b);   // int형 변수의 주소를 바노한하는 함수 선언
// 
// int main()
// {
// 	int* resp;            // 반환값을 저장할 포인터 resp(result pointer)
// 
// 	resp = sum(10, 20);   // 반환된 주소는 resp에 저장
// 	printf("두 정수의 합 : %d\n", *resp);  // resp가 가리키는 변숫값 출력
// 
// 	return 0;
// }
// 
// int* sum(int a, int b)    // int형 변수의 주소를 반환하는 함수
// {
// 	static int res;       // 정적 지역 변수
// 
// 	res = a + b;          // 두 정수의 합을 res(result)에 저장
// 
// 	return &res;          // 정적 지역 변수의 주소 반환
// }

// 결과
// 두 정수의 합 : 30

/* 부가 설명
* 호출하는 함수가 주소를 주고 호출하듯이 호출되는 함수도 주소를 반환할 수 있습니다.
* 예제3)에 15행 sum 함수는 매개변수에 받은 두 정수를 더한 후에 직접 반환하지 않고 res 변수에 저장하고
* res의 주소를 반환합니다. 이 경우 호출한 함수에서는 그 값을 포인터에 저장하고 간접 참조 연산을 수행해
* 언제든지 두 정수의 합을 사용할 수 있습니다. 10행에서는 단지 그 값을 출력하고 있지만, resp가 가리키는
* 변수 res의 값을 바꾸는 것도 가능합니다. 이처럼 주소를 반환하는 함수를 만들 때는 2가지 주의할 점이 있습니다.
* 
* ※ 주소를 반환하는 함수를 만들때 주의할점 ※
* 1. 반환값의 자료형은 반환값을 저장할 포인터의 자료형과 같아야 합니다.
* - 즉 sum 함수는 int형 변수인 res의 주소를 반환하므로 그 값을 저장할 포인터는 예제3)의 7행과 같이 int *형으로 선언해야 하며
* sum 함수의 반환형도 int *형이 되어야 합니다.
*
* 2. 지역 변수의 주소를 반환해서는 안 됩니다.
* - 예제3) 17행의 변수 res는 static을 사용한 정적 지역 변수로 함수가 반환된 후에도 저장 공간이 계속 유지되므로 호출한 함수에서
* 포인터 연산을 통해 언제든지 그 변수를 사용할 수 있습니다.
* ex) static int res;  <- 예제3)의 17행 정적 지역 변수
* 그러나 일반 지역 변수는 함수가 반환되면 저장 공간이 회수되어 언제 다른 용도로 재활용될지 알 수 없습니다. 따라서 지역 변수의 주소를
* 반환하면 안 됩니다. 컴파일러는 이 경우 다음과 같은 경고 메시지로 알려줍니다.
* warning C4172 : 지역 변수 또는 임시 변수의 주소를 반환하고 있습니다.
* 
* 정적 지역 변수나 전역 변수의 주소를 반환하거나 호출하는 함수에 있는 변수의 주소를 인수로 받은 경우 그 주소를 다시 반환할 수 있습니다.
* 그 외에도 동적 할당한 메모리의 주소도 가능한데 동적 할당은 16장에서 자세히 다룹니다.
*/
#pragma endregion

#pragma region (3)가지 키워드로 끝내는 핵심 포인트
/*
* 1. 값을 복사해서 인수로 전달하면 호출하는 함수의 값은 바뀌지 않는다.
* 2. 호출하는 함수의 값을 바꾸러면 주소를 인수로 전달해야한다.
* 3. 정적 지역 변수나 전역 변수와 같이 함수가 반환된 후에도 저장 공간이 유지되는 경우에만 주소를 반환한다. 
*/

/* ※ 표로 정리하는 핵심 포인트 ※
* -----------------------------------------------------------------
*ㅣ      공유방법       |    호출하는 함수     |    호출되는 함수    |
*ㅣㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
*ㅣ값을 넘겨준다.        |    int a = 10;     | void func(int b);  |
*ㅣ                     |    func(a);        |                    |
*ㅣㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
*ㅣ값을 반환 받는다.     |       int a;       |      return b;     |
*ㅣ                     |    a = func();     |                    |
*ㅣㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
*ㅣ주소를 넘겨준다.      |    int a = 10;     | void func(int *p); |
*ㅣ                     |     func(&a);      |                    |
*ㅣㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
*ㅣ주소를 반환 받는다.   |      int *p;       |  static int b = 10; |
*ㅣ                     |     p = func();    |      return &b;    |
*ㅣㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
*/

#pragma endregion

#pragma region 확인 문제
/*
* 지금까지 둘 이상의 함수에서 데이터를 공유하는 방법을 살펴 보았습니다. 크게 나누면 처리할 값을 직접 주고받는 경우와
* 값을 사용할 수 있도록 주소를 주고 받는 경우가 있습니다. 어떤 방식이 더 좋은지 상황에 따라 달라집니다. 따라서
* 다양한 문제를 풀면서 함수의 설계 방식을 연습해 보겠습니다. 
*/

/*1. 함수 원형과 데이터 공유 방법이 일치하도록 연결하세요.
* 
* ⓐ. void swap(int *pa, int *pb);  ⓐ            ⓑ 값을 복사해서 전달하는 방법
* 
* ⓑ. double avg(int a, int b);     ⓑ            ⓒ 주소를 반환하는 함수
*                                 
* ⓒ. char* get_str(void);          ⓒ            ⓐ 주소를 전달하는 방법
* 
*/

/* 2. 다음은 키보드로부터 정수를 입력 받은후에 값이 저장된 변수의 주소를 반환하는 함수입니다.
* 구현에 문제가 있는 부분을 찾고 그이유를 적으세요.
* int* get_num(void)
* {
* 	int n;
* 	scanf_s("%d", &n);
* 	return &n;
* }
* 
* 이유 : 지역변수로 주소를 반환하면 함수를벗어날때 지역변수는 초기화되어 주소값이 반환되지못하고 사라집니다.
* 그러므로 함수안에 지역변수 int n을 static 예약어를 사용하여 static int n 으로 재작성해서 정적 지역변수로 선언해야합니다.
*/ 

/* 3. 다음 프로그램의 실행결과가 30이 되도록 빈칸에 알맞은 수식을 적으세요.
* void add_by_pointer(int* pa, int* pb, int* pr)
* {
* 	*pr = *pa + *pb;
* 
* }
* int main()
* {
* 	int a = 10, b = 20, res = 0;
* 	add_by_pointer(&a, &b, &res);
* 	printf("%d", res);
* 
* 	return 0;
* }
* 
* 이유 : add_by_pointer 함수는 반환값을 사용하지 않고 포인터에 매개변수를 통해 인수를 받고 결과값도 매개변수 pr를
* 통해 호출한 함수의 변수 res에 직접 저장합니다.
*/

#pragma endregion

#pragma region 도전 실전 예제!

// 도전! 전역 변수 교환 프로그램

// void input_data(int* pa, int* pb);
// void swap_data(void);
// void print_data(int a, int b);
// 
// int a, b;
// 
// int main(void)
// {
// 	input_data(&a, &b);   // 전역 변수에 정수 값 입력
// 	swap_data();          // 두 변수 교환
// 	print_data(a, b);     // 교환된 변숫값 출력
// 
// 	return 0;
// }
// 
// void input_data(int* pa, int* pb)
// {
// 	printf("두 정수 값 입력\n");
// 	scanf_s("%d %d", pa, pb);
// }
// 
// void swap_data(void)
// {
// 	int temp;
// 	temp = a;
// 	a = b;
// 	b = temp;
// }
// 
// void print_data(int a, int b)
// {
// 	printf( "두 정수 값 : %d, %d", a, b);
// }

// 결과 : 입력 -> 10, 20
// 출력 : 20, 10
#pragma endregion
